{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"architecture/","text":"Plugins \u00b6 These plugins are automatically installed with Molten.","title":"Plugins"},{"location":"architecture/#plugins","text":"These plugins are automatically installed with Molten.","title":"Plugins"},{"location":"architecture/roles/","text":"Roles & Permissions Overview \u00b6 The Leverege Stack uses a role-based access control system. Role-based access control refers to the idea of assigning permissions to users based on their role within an organization. It offers a simple, manageable approach to access management that is less prone to error than assigning permissions to users individually. When using RBAC, you analyze the needs of your users and group them into roles based on common responsibilities. You then assign one or more roles to each user and one or more permissions to each role. The user-role and role-permissions relationships make it simple to perform user assignments since users no longer need to be managed individually, but instead have privileges that conform to the permissions assigned to their role(s). For example, if you were using RBAC to control access for a cow tracking application, you could give farm manager a role that allows them create locations, add & manage users, and view employee performance analytics. Farm hands may have a role that only shows them the cows at a given location and any alerts associated with that location. When planning your access control strategy, it's best practice to assign users the fewest number of permissions that allow them to get their work done. Terminology \u00b6 Field Definition Permission Defines a single action that can be done (create, read, update, delete, list) Role A group of permissions that indicate what a user with this role can do. Usually based on the user personas of a given application. Roles have a specific ID referred to as role ID Resource ID The unique identity of something like a device, system, project, location, asset, etc. User ID The unique ID of the \u2018user\u2019. Can be any ID representing the account. This is also the API Access ID. User Role Combines a user ID and a role ID with a resource ID CRUDL An acronym that stands for Create, Read, Update, Delete, List. These are the most common operations that can be performed on objects in the Leverege Stack Roles \u00b6 Essentially, a role is a collection of permissions that you can apply to users. Using roles makes it easier to add, remove, and adjust permissions than assigning permissions to users individually. As your user base increases in scale and complexity, roles become particularly useful. You can also use roles to collect permissions defined for various APIs. For example, say you have a third-party tool that tracks your barn equipment. Your barn equipment API role could have a Create equipment in a location & Update equipment in a location permissions allow the API to create and update equipment in our database. User Roles \u00b6 User Roles represent bindings between a user ID, role ID, and resource ID. As an example, a user role represents \u201cgiving Steve (User ID) the ability to act as a Farm Hand (Role ID) at Eric\u2019s Farm (Resource ID)\u201d.","title":"Roles & Permissions Overview"},{"location":"architecture/roles/#roles-permissions-overview","text":"The Leverege Stack uses a role-based access control system. Role-based access control refers to the idea of assigning permissions to users based on their role within an organization. It offers a simple, manageable approach to access management that is less prone to error than assigning permissions to users individually. When using RBAC, you analyze the needs of your users and group them into roles based on common responsibilities. You then assign one or more roles to each user and one or more permissions to each role. The user-role and role-permissions relationships make it simple to perform user assignments since users no longer need to be managed individually, but instead have privileges that conform to the permissions assigned to their role(s). For example, if you were using RBAC to control access for a cow tracking application, you could give farm manager a role that allows them create locations, add & manage users, and view employee performance analytics. Farm hands may have a role that only shows them the cows at a given location and any alerts associated with that location. When planning your access control strategy, it's best practice to assign users the fewest number of permissions that allow them to get their work done.","title":"Roles &amp; Permissions Overview"},{"location":"architecture/roles/#terminology","text":"Field Definition Permission Defines a single action that can be done (create, read, update, delete, list) Role A group of permissions that indicate what a user with this role can do. Usually based on the user personas of a given application. Roles have a specific ID referred to as role ID Resource ID The unique identity of something like a device, system, project, location, asset, etc. User ID The unique ID of the \u2018user\u2019. Can be any ID representing the account. This is also the API Access ID. User Role Combines a user ID and a role ID with a resource ID CRUDL An acronym that stands for Create, Read, Update, Delete, List. These are the most common operations that can be performed on objects in the Leverege Stack","title":"Terminology"},{"location":"architecture/roles/#roles","text":"Essentially, a role is a collection of permissions that you can apply to users. Using roles makes it easier to add, remove, and adjust permissions than assigning permissions to users individually. As your user base increases in scale and complexity, roles become particularly useful. You can also use roles to collect permissions defined for various APIs. For example, say you have a third-party tool that tracks your barn equipment. Your barn equipment API role could have a Create equipment in a location & Update equipment in a location permissions allow the API to create and update equipment in our database.","title":"Roles"},{"location":"architecture/roles/#user-roles","text":"User Roles represent bindings between a user ID, role ID, and resource ID. As an example, a user role represents \u201cgiving Steve (User ID) the ability to act as a Farm Hand (Role ID) at Eric\u2019s Farm (Resource ID)\u201d.","title":"User Roles"},{"location":"architecture/roles/permission/","text":"Permissions \u00b6 Terminology \u00b6 Field Definition System Systems are buckets of devices that can be used to logically separate sets of devices from each other. Systems use only the common CRUDL permissions. Device Devices are digital shadows of physical objects. They can represent hardware devices like trackers, physical assets like cows, or organizational buckets like companies. Blueprint Blueprints define the structure of our devices and relationship between device entities in our solution. Some permissions are generated when Blueprints or relationship Attributes are made. Common Permissions \u00b6 Some permissions can be seen used against nearly every type of object in the platform. These are the CRUDL permissions. CRUDL is an acronym that stands for Create, Read, Update, Delete, List. Create - the permission to create an object Read - given some object\u2019s id, the ability to read its data Update - given some object\u2019s id, the ability to update its data Delete - given some object\u2019s id, the ability to delete it List - the ability to get a list of all objects without having to know their ids Permission Categories \u00b6 When adding permissions to roles, you'll see that there are 3 different categories of permissions. Category Definition Custom Custom refers to custom permissions built for custom actions or access in your project Project Project permissions are permissions that are autogenerated for your blueprints, relationships, etc. They are project-specific and relate to your data architecture. Imagine Imagine permissions are permissions relating to modules and features that are the same across projects. An example of this is user management permissions. System Permissions \u00b6 Systems are buckets of devices that can be used to logically separate sets of devices from each other. Systems use only the common CRUDL permissions. Device \u00b6 Devices are digital shadows of physical objects. They can represent hardware devices like trackers, physical assets like cows, or organizational buckets like companies. Devices use the common CRUDL permissions, but also have the following custom permissions: readData - Read not only a device\u2019s header information (like a name), but also its data, which might include things like sensor readings, addresses, or contact information. readHistory - View the changes to a device\u2019s data over time readEvents - View the relevant events that have occurred to a device over time. Might include things like threshold violations or alerts. updateEvents - Update or create device events sendMessage - Send a device a message. This may only be relevant if a device is physically capable of receiving messages, like in the instance of configuring a tracker or other piece of hardware. runSimulation - Simulate a device readByNetworkAlias - Get devices by their network ids deleteRelationship - Delete a device's relationship. For instance, removing a cow from a barn stall, or unpairing a car and a tracker. Deleting a relationship will not delete the device. createRelationship - Create a device\u2019s relationships. For instance, pairing a car and tracker. Creating a relationship does not create a device. updateData - Update a device\u2019s data. This generates historical data points, and will be reflected to anyone with a readData permission. An example of updating a device\u2019s data would be setting a Farm\u2019s address. updateAnyData - A more powerful version of updateData. Users with updateData are restricted to updating fields as validated by the device\u2019s Blueprint. Users with updateAnyData are not subject to that restriction. As an example, a user with updateData likely couldn\u2019t change the temperature reported by a sensor, but a user with updateAnyData could. This permission is usually only for administrators. Blueprints & Relationships \u00b6 Some permissions are generated when Blueprints or relationship Attributes are made. They tend to follow a similar form as the Device permissions. The main difference is that Blueprint or Attribute level permissions only allow a user to perform actions on Devices of a given type, or at certain paths in the hierarchy as defined by the Attributes. Their permissions are as follows: Blueprints: \u00b6 Create : create Devices of a type Read : read Devices of a type (if you know the id) Update : update Devices of a type Delete : delete Devices of a type List : list Devices of a type Read History: read the history of any Devices of a given type Read Events: read the events of any Devices of a given type Update Events: update the events of any Devices of a given type Send Messages: send messages to any Devices of a given type Delete Relationships: delete any relationships that go to Devices of a given type Create Relationships: delete any relationships that go to Devices of a given type Update Data: update the data of any Devices of a given type Update Any Data: update any data (unvalidated) of any Devices of a given type Relationship Attributes \u00b6 Create in a : Create Devices of a given Blueprint at a given place in the hierarchy Read from a : Read Devices of a given Blueprint at a given place in the hierarchy (must know the id) Update in a : Update Devices of a given Blueprint at a given place in the hierarchy Delete from a : Delete Devices of a given Blueprint at a given place in the hierarchy List in a : List Devices of a given Blueprint at a given place in the hierarchy Read History in a : Read the history of Devices of a given Blueprint at a given place in the hierarchy Read Events in a : Read the events of Devices of a given Blueprint at a given place in the hierarchy Update Events in a : Update the events of Devices of a given Blueprint at a given place in the hierarchy Send Messages in a : Send messages to Devices of a given Blueprint at a given place in the hierarchy Remove from a : Delete relationships to Devices of a given Blueprint at a given place in the hierarchy Add to a : Create Relationships to Devices of a given Blueprint at a given place in the hierarchy Update data in a : Update the data of Devices of a given Blueprint at a given place in the hierarchy Update Any Data in a : Update any data (unvalidated) of Devices of a given Blueprint at a given place in the hierarchy Example \u00b6 In our farming example, let's imagine we have the following hierarchy. Example of Farm Hierarchy Let's say you want to give your farmhand role the ability to create a cow, but only in a location. Your permission for this would be: Create a cow in a location This permission allows the user to create a cow when they are at the location level cows page. This user would not be able to create a cow on the cows page at a company. Now, you want your farm manager role to be able to create a cow in a location and in a company. They would have two permissions on their role: Create a cow in a location Create a cow in a company Finally, let's say instead of letting the farm manager role create cows in a location or in a company, you want them to be able to create a cow anywhere in the system. For this, you would use the following blueprint-level permission Can create a cow API Access \u00b6 ApiAccess objects represent sets of tokens/keys that allow third party services to connect to the Leverege Platform (usually as project level admins) using OAuth2. ApiAccesses use only the common CRUDL permissions. User Management \u00b6 Users are the users of a give IoT project. Users use the common CRUDL permissions, but also have the following custom permission. assignRoles - allows a user to assign roles to other users. Unless they\u2019re admin, users can only assign roles they already have. For the common CRUDL permissions, when applied to user management, they look like the following. Users \u00b6 Create Delete List Read Update Network \u00b6 Networks represent a collection of mappings from external ids to internal Leverege ids. Networks ensure that only one device at a given time can have a given external mapping. For example, if you are sending tracker data into the Leverege Stack, that data will need some form of identifier to say what device it is from. Many times that id is chosen by the manufacturer, say a serial number or SKU. A network will map that serial number or SKU to a device\u2019s unique id in the Leverege Stack, and ensure that mapping is one-to-one. Networks use only the common CRUDL permissions. Common Permission Needed for Pairing readByNetworkAlias is a common permission that must be added to a role if that role is responsible for pairing one device to another and the network ID is used in the pairing form Configuration \u00b6 By default, any user can perform UI configuration for themselves. To learn move about what UI configuration entails, please visit our section in the documentation on configuration. Note that an engineer has the ability to hide configuration on a per-role basis in the config file on the UI. System-Level Access Required For a user to configure UIs for other users, they must have a role at the system-level that has the resource permissions For a user to be able to configure a UI for a given role or for all roles, they will need specific permissions against resources, which refer to the UI resources used to show configurations per role. Resource permissions are common CRUDL permissions. Resource Permissions \u00b6 Create Delete List Read Update","title":"Permissions"},{"location":"architecture/roles/permission/#permissions","text":"","title":"Permissions"},{"location":"architecture/roles/permission/#terminology","text":"Field Definition System Systems are buckets of devices that can be used to logically separate sets of devices from each other. Systems use only the common CRUDL permissions. Device Devices are digital shadows of physical objects. They can represent hardware devices like trackers, physical assets like cows, or organizational buckets like companies. Blueprint Blueprints define the structure of our devices and relationship between device entities in our solution. Some permissions are generated when Blueprints or relationship Attributes are made.","title":"Terminology"},{"location":"architecture/roles/permission/#common-permissions","text":"Some permissions can be seen used against nearly every type of object in the platform. These are the CRUDL permissions. CRUDL is an acronym that stands for Create, Read, Update, Delete, List. Create - the permission to create an object Read - given some object\u2019s id, the ability to read its data Update - given some object\u2019s id, the ability to update its data Delete - given some object\u2019s id, the ability to delete it List - the ability to get a list of all objects without having to know their ids","title":"Common Permissions"},{"location":"architecture/roles/permission/#permission-categories","text":"When adding permissions to roles, you'll see that there are 3 different categories of permissions. Category Definition Custom Custom refers to custom permissions built for custom actions or access in your project Project Project permissions are permissions that are autogenerated for your blueprints, relationships, etc. They are project-specific and relate to your data architecture. Imagine Imagine permissions are permissions relating to modules and features that are the same across projects. An example of this is user management permissions.","title":"Permission Categories"},{"location":"architecture/roles/permission/#system-permissions","text":"Systems are buckets of devices that can be used to logically separate sets of devices from each other. Systems use only the common CRUDL permissions.","title":"System Permissions"},{"location":"architecture/roles/permission/#device","text":"Devices are digital shadows of physical objects. They can represent hardware devices like trackers, physical assets like cows, or organizational buckets like companies. Devices use the common CRUDL permissions, but also have the following custom permissions: readData - Read not only a device\u2019s header information (like a name), but also its data, which might include things like sensor readings, addresses, or contact information. readHistory - View the changes to a device\u2019s data over time readEvents - View the relevant events that have occurred to a device over time. Might include things like threshold violations or alerts. updateEvents - Update or create device events sendMessage - Send a device a message. This may only be relevant if a device is physically capable of receiving messages, like in the instance of configuring a tracker or other piece of hardware. runSimulation - Simulate a device readByNetworkAlias - Get devices by their network ids deleteRelationship - Delete a device's relationship. For instance, removing a cow from a barn stall, or unpairing a car and a tracker. Deleting a relationship will not delete the device. createRelationship - Create a device\u2019s relationships. For instance, pairing a car and tracker. Creating a relationship does not create a device. updateData - Update a device\u2019s data. This generates historical data points, and will be reflected to anyone with a readData permission. An example of updating a device\u2019s data would be setting a Farm\u2019s address. updateAnyData - A more powerful version of updateData. Users with updateData are restricted to updating fields as validated by the device\u2019s Blueprint. Users with updateAnyData are not subject to that restriction. As an example, a user with updateData likely couldn\u2019t change the temperature reported by a sensor, but a user with updateAnyData could. This permission is usually only for administrators.","title":"Device"},{"location":"architecture/roles/permission/#blueprints-relationships","text":"Some permissions are generated when Blueprints or relationship Attributes are made. They tend to follow a similar form as the Device permissions. The main difference is that Blueprint or Attribute level permissions only allow a user to perform actions on Devices of a given type, or at certain paths in the hierarchy as defined by the Attributes. Their permissions are as follows:","title":"Blueprints &amp; Relationships"},{"location":"architecture/roles/permission/#blueprints","text":"Create : create Devices of a type Read : read Devices of a type (if you know the id) Update : update Devices of a type Delete : delete Devices of a type List : list Devices of a type Read History: read the history of any Devices of a given type Read Events: read the events of any Devices of a given type Update Events: update the events of any Devices of a given type Send Messages: send messages to any Devices of a given type Delete Relationships: delete any relationships that go to Devices of a given type Create Relationships: delete any relationships that go to Devices of a given type Update Data: update the data of any Devices of a given type Update Any Data: update any data (unvalidated) of any Devices of a given type","title":"Blueprints:"},{"location":"architecture/roles/permission/#relationship-attributes","text":"Create in a : Create Devices of a given Blueprint at a given place in the hierarchy Read from a : Read Devices of a given Blueprint at a given place in the hierarchy (must know the id) Update in a : Update Devices of a given Blueprint at a given place in the hierarchy Delete from a : Delete Devices of a given Blueprint at a given place in the hierarchy List in a : List Devices of a given Blueprint at a given place in the hierarchy Read History in a : Read the history of Devices of a given Blueprint at a given place in the hierarchy Read Events in a : Read the events of Devices of a given Blueprint at a given place in the hierarchy Update Events in a : Update the events of Devices of a given Blueprint at a given place in the hierarchy Send Messages in a : Send messages to Devices of a given Blueprint at a given place in the hierarchy Remove from a : Delete relationships to Devices of a given Blueprint at a given place in the hierarchy Add to a : Create Relationships to Devices of a given Blueprint at a given place in the hierarchy Update data in a : Update the data of Devices of a given Blueprint at a given place in the hierarchy Update Any Data in a : Update any data (unvalidated) of Devices of a given Blueprint at a given place in the hierarchy","title":"Relationship Attributes"},{"location":"architecture/roles/permission/#example","text":"In our farming example, let's imagine we have the following hierarchy. Example of Farm Hierarchy Let's say you want to give your farmhand role the ability to create a cow, but only in a location. Your permission for this would be: Create a cow in a location This permission allows the user to create a cow when they are at the location level cows page. This user would not be able to create a cow on the cows page at a company. Now, you want your farm manager role to be able to create a cow in a location and in a company. They would have two permissions on their role: Create a cow in a location Create a cow in a company Finally, let's say instead of letting the farm manager role create cows in a location or in a company, you want them to be able to create a cow anywhere in the system. For this, you would use the following blueprint-level permission Can create a cow","title":"Example"},{"location":"architecture/roles/permission/#api-access","text":"ApiAccess objects represent sets of tokens/keys that allow third party services to connect to the Leverege Platform (usually as project level admins) using OAuth2. ApiAccesses use only the common CRUDL permissions.","title":"API Access"},{"location":"architecture/roles/permission/#user-management","text":"Users are the users of a give IoT project. Users use the common CRUDL permissions, but also have the following custom permission. assignRoles - allows a user to assign roles to other users. Unless they\u2019re admin, users can only assign roles they already have. For the common CRUDL permissions, when applied to user management, they look like the following.","title":"User Management"},{"location":"architecture/roles/permission/#users","text":"Create Delete List Read Update","title":"Users"},{"location":"architecture/roles/permission/#network","text":"Networks represent a collection of mappings from external ids to internal Leverege ids. Networks ensure that only one device at a given time can have a given external mapping. For example, if you are sending tracker data into the Leverege Stack, that data will need some form of identifier to say what device it is from. Many times that id is chosen by the manufacturer, say a serial number or SKU. A network will map that serial number or SKU to a device\u2019s unique id in the Leverege Stack, and ensure that mapping is one-to-one. Networks use only the common CRUDL permissions. Common Permission Needed for Pairing readByNetworkAlias is a common permission that must be added to a role if that role is responsible for pairing one device to another and the network ID is used in the pairing form","title":"Network"},{"location":"architecture/roles/permission/#configuration","text":"By default, any user can perform UI configuration for themselves. To learn move about what UI configuration entails, please visit our section in the documentation on configuration. Note that an engineer has the ability to hide configuration on a per-role basis in the config file on the UI. System-Level Access Required For a user to configure UIs for other users, they must have a role at the system-level that has the resource permissions For a user to be able to configure a UI for a given role or for all roles, they will need specific permissions against resources, which refer to the UI resources used to show configurations per role. Resource permissions are common CRUDL permissions.","title":"Configuration"},{"location":"architecture/roles/permission/#resource-permissions","text":"Create Delete List Read Update","title":"Resource Permissions"},{"location":"architecture/roles/role/","text":"Creating a Role \u00b6 The Leverege Stack builds up a large number of pre-configured roles based on blueprints that a user might wish to employ in their system during the early start-up stages. Common roles include things like Device Viewer, Device Editor, and Device List Editor. Realistically, once you reach a phase in your development where you have end-users, custom roles are needed to fine-tune your solution to your use case. Commonly, users create custom roles that match 1-to-1 with the personas of a customer or product. A persona is a set of responsibilities a certain type of user has to carry out one or more business processes. Examples of personas in an IoT application include Company Admin, Location Admin, Location Editor, and Location Viewer. In Architect, users would create roles corresponding to each of these roles. To create a custom role, you'll head to Architect and select the Roles tab in the left sidebar of your project. There, you will be able to create custom roles for your project by selecting the Create Role button in the top right corner. Create Role Form Terminology \u00b6 Field Definition Name The name is the path of the role. This must be named using camelCase. For example, Location Admin would be written locationAdmin Display Name This is the UI friendly version of the name. In the above example, you might write Location Admin Category This is an optional field where you can assign a role a category Description This is an optional field to help others understand what this role is for Metadata For a given role, you have a host of metadata options to help configure your UI. Review these in the role-specific UI setup section Assigning Permissions to a Custom Role \u00b6 Once your role is created, you can assign permissions to the role. To do so, click the edit button next to the permissions section in the right hand panel. That will open the following modal. Add Permissions Form Note that you can search and filter permissions in the permissions pop-up. By default, the filter is set to show custom and project permissions. To show imagine permissions, open the filter dropdown and select imagine.","title":"Creating Roles"},{"location":"architecture/roles/role/#creating-a-role","text":"The Leverege Stack builds up a large number of pre-configured roles based on blueprints that a user might wish to employ in their system during the early start-up stages. Common roles include things like Device Viewer, Device Editor, and Device List Editor. Realistically, once you reach a phase in your development where you have end-users, custom roles are needed to fine-tune your solution to your use case. Commonly, users create custom roles that match 1-to-1 with the personas of a customer or product. A persona is a set of responsibilities a certain type of user has to carry out one or more business processes. Examples of personas in an IoT application include Company Admin, Location Admin, Location Editor, and Location Viewer. In Architect, users would create roles corresponding to each of these roles. To create a custom role, you'll head to Architect and select the Roles tab in the left sidebar of your project. There, you will be able to create custom roles for your project by selecting the Create Role button in the top right corner. Create Role Form","title":"Creating a Role"},{"location":"architecture/roles/role/#terminology","text":"Field Definition Name The name is the path of the role. This must be named using camelCase. For example, Location Admin would be written locationAdmin Display Name This is the UI friendly version of the name. In the above example, you might write Location Admin Category This is an optional field where you can assign a role a category Description This is an optional field to help others understand what this role is for Metadata For a given role, you have a host of metadata options to help configure your UI. Review these in the role-specific UI setup section","title":"Terminology"},{"location":"architecture/roles/role/#assigning-permissions-to-a-custom-role","text":"Once your role is created, you can assign permissions to the role. To do so, click the edit button next to the permissions section in the right hand panel. That will open the following modal. Add Permissions Form Note that you can search and filter permissions in the permissions pop-up. By default, the filter is set to show custom and project permissions. To show imagine permissions, open the filter dropdown and select imagine.","title":"Assigning Permissions to a Custom Role"},{"location":"config/","text":"In this section, we will be covering how to configure the UI and save configuration to dashboards to be used throughout the application.","title":"Index"},{"location":"config/config-basics/","text":"Configuration and Dashboard Basics \u00b6 Leverege Amplify provides users with the ability to configure the look, feel, and behavior of the vast majority of components in the application. Examples of components include tables, maps, rollover cards, and graphs. Configuring a page of the application relies on three primary steps: Configuring each component using its configuration panel . A configuration panel is a popup or screen where a user can configure and change settings of an individual component on a page Saving the components to a dashboard . A dashboard is a single view that arranges and displays all the components on the page Setting where and for whom the dashboard appears . By setting the dashboard availability and defaults, a user can specify on which pages and for which types of users the dashboard is seen. The following sections describe how to interact with configuration panel, save configured components to a dashboard, and administer a dashboard to be seen by either all or select users of an application. Accessing a Configuration Panel \u00b6 Each configurable component in the application is controlled by a configuration panel. All configuration panels share a similar layout and set of functions. Accessing the configuration panel differs by component, but most can be identified with the gear icon. Refer to the specific component\u2019s documentation for instructions on how to exactly access its configuration panel. Configuration is only available for those users with the appropriate permission. Primary Configuration Area \u00b6 The primary configuration area on a configuration page is typically a 2-panel card. For example, tables have a configuration area where the list of available fields are selectable on the left and the configurable values are displayed on the right. [Screenshot of table configuration panel with each side outlined and labeled] The primary configuration may vary slightly depending on the UI component. For example, in the search bar configuration, the configuration area is a list of the searchable fields with checkboxes. [Screenshot of search bar configuration] Versions \u00b6 A version is a saved configuration profile for an individual UI component. A user may use versions when experimenting with the configuration of a component before rolling it out to others. A version is specific to the user, in that no users can see another\u2019s user versions. Create A Version \u00b6 To create a version, use the Save To > Create Version button in the upper right of the configuration panel. Save A Version \u00b6 Once created, users can save their current component\u2019s configuration to the version by clicking Save To > Versions and selecting the version. Once saved, click Apply to apply the configuration to the component. Load A Version \u00b6 To retrieve a previously saved version, click the Load From button in the upper left of the configuration panel and select the desired version. This will load that version\u2019s configuration into the panel. Click Apply to the apply that version\u2019s configuration to the component. [Save To Screenshot] [Load From Screenshot] Delete A Version \u00b6 To delete a version, click the three dots icon next to Save To > Delete Versions , and select the version to delete. Confirm the deletion in the prompt. Configuring a Page \u00b6 The high-level steps to configuring a page are: Pick the role and page : If the configured page is applicable to a specific role, assume the role using the role selector. Then, navigate to the page where the configuration should apply. Configure each component on the page : Refer to the UI component documentation as necessary Save the configured state to a dashboard : The dashboard can either be an existing or new dashboard. If new, specify where and to which users the dashboard can be shown as a selection option. Set the priority of the dashboards by setting defaults : once the dashboard is saved, determine when it should be shown to a user in relative priority to other dashboards already configured for the page Pick the Role and Page \u00b6 It\u2019s common for an application to present data on the same page differently to users with different roles. For example, a field engineer may want to see the battery level and firmeware version of a device, while a customer service rep may want to see its last known location. If the configuration is applicable to a specific role, assume the role by selecting it from the role selector. Access the role selector by clicking the username in upper right of the page and selecting the role under User Role . [Screenshot of role selector] Navigate to the page to where the configuration should be applied. For example, if the configuration is intended for the Assets page, navigate to the Assets page. If the configuration is meant to be applied to an existing dashboard, load the dashboard by selecting it from the dashboard selector at the top of the page. [Screenshot of the dashboard selector] Configure Each Component on the Page \u00b6 Use the layout controller to place the desired components on the page. Refer to the documentation for the layout controller for more details. [Screenshot of layout controller on the UI] For each component, access the control panel and make the desired configuration changes. Click Apply in the configuration panel of that component once all the desired changes are performed. Refer to the document for the specific component for more details. Save the Configured State to a Dashboard \u00b6 Once all configuration to all components have been completed, a user can save the entire state of the page to a dashboard. To save the configured state to the current dashboard, click the check mark icon next to the dashboard selector. To revert the changes back to its previously saved state, click the reverse circle icon. [Screenshot of save & revert of current dashboard] Note: The Default dashboard is a user\u2019s personal dashboard configuration for exact page location. Saving the configuration to the dashboard titled \u201cDefault\u201d will only apply the configuration as the default dashboard to the current user, for currently assumed role, and to exact path for which the configuration was performed. For example, if a user A is on the Company > Assets page as Role A and saves a new configuration to the Default dashboard at that page, it will affect only the Default dashboard for User A while they are using Role A on the Company > Assets page. It will not impact the Default dashboard for user B at Company > Assets using Role A, not impact Default dashboard for any users at Company > Assets using Role B, and not impact the Default dashboard of user A at other Asset paths (e.g. Location > Assets) using Role A. To save the configured state to a new dashboard, click the three-dot icon next to the dashboard selector and click Save Dashboard As\u2026 In the Save Dashboard As\u2026 popup, enter the name of the new dashboard Select the availability of the dashboard from the Available To dropdown: Role Level - Any on this page: The option to select this dashboard will appear for any users of role X on this exact page path, with role X being the currently assumed role of the user doing the configuration. For example, only show this dashboard for users with Role A and on the Assets page at the Company > Assets path. This will create an option in the dropdown under the \u201cRole\u201d section of the dashboard selector. Page Level - Any user on this page: The option to select this dashboard will appear for any user of any role on this exact page path. For example, show this dashboard for all users on the Assets page at the Company > Assets path. This will create an option in the dropdown under the \u201cPage\u201d section. Blueprint Level - Any user on the page showing this page's Blueprint type: The option to select this dashboard will appear for any user of any role on a page of the same Blueprint type as the one being configured. For example, show this dashboard for all users on all Asset pages, regardless of its specific path. This will create an option in the dropdown under the section named after the Blueprint type (e.g. Assets). Personal Blueprint Level - Me on any page showing this page's Blueprint type: The option to select this dashboard will appear for only the current user on any page of any role on a page of the same Blueprint type as the one being configured. This will create an option in the dropdown under the \u201cMine\u201d section. Looking for an option to save the configured page to the current user for the current role and current path? Save the dashboard to the Default dashboard by click the check mark next to the left of the dashboard selector? Set the Defaults Of The Page \u00b6 The previous section on Saving the Dashboard produces a dashboard that is available for selection by a user on a give page. It does not yet specify whether it will load by default when a user visits that page. In order to apply the dashboard to pages so that it loads for given users, page locations, and roles, set the dashboard defaults. Click the three dots icon next to the dashboard selector to load the list of editable dashboards Depending on how many dashboards you have configured and their availability on the page, you will see dashboards separated into the following categories based on availability criteria: Role - Dashboards that are available to show on this page based on the user\u2019s role Page - Dashboards that are available to show on this page based on the user\u2019s page path in the application [Name of Blueprint Type] (e.g. Assets) - Dashboards that are available to show on this page based on the type of blueprint that page is showing Mine - Personal dashboards that are available to show on this page based on the type of blueprint that page is showing To set a dashboard to show by default on the page when it meets the availability criteria, select the dashboard > Use as Default . Only one dashboard from each section can be set as default (e.g. only one Role-level dashboard can be set as default, one Page-level dashboard can be set as default, etc.) In the event that multiple dashboards across each section is set as default, the application shows the default dashboard based on this ranking (from highest to lowest): Mine Role Page Blueprint Default Managing Dashboards \u00b6 Renaming A Dashboard \u00b6 To rename a dashboard, click the three dots icon next to the dashboard selector and select the [dashboard name] > Rename . Delete a Dashboard \u00b6 To delete a dashboard, click the three dots icon next to the dashboard selector and select the dashboard name > Delete . If the deleted dashboard was displayed on the page, the page will switch to showing the Default dashboard. Reset Personal Default Dashboard Back to Stock \u00b6 If the Default dashboard has been changed and a user wishes to reset it back to its original state (e.g. \u201cfactory defaults\u201d), select the Default dashboard from the dashboard selector. Then click the three dots icon next to the dashboard selector > Reset to Default Dashboard . Configuration Best Practices \u00b6 We\u2019re working on making a list of best practices, stay tuned!","title":"Getting Started"},{"location":"config/config-basics/#configuration-and-dashboard-basics","text":"Leverege Amplify provides users with the ability to configure the look, feel, and behavior of the vast majority of components in the application. Examples of components include tables, maps, rollover cards, and graphs. Configuring a page of the application relies on three primary steps: Configuring each component using its configuration panel . A configuration panel is a popup or screen where a user can configure and change settings of an individual component on a page Saving the components to a dashboard . A dashboard is a single view that arranges and displays all the components on the page Setting where and for whom the dashboard appears . By setting the dashboard availability and defaults, a user can specify on which pages and for which types of users the dashboard is seen. The following sections describe how to interact with configuration panel, save configured components to a dashboard, and administer a dashboard to be seen by either all or select users of an application.","title":"Configuration and Dashboard Basics"},{"location":"config/config-basics/#accessing-a-configuration-panel","text":"Each configurable component in the application is controlled by a configuration panel. All configuration panels share a similar layout and set of functions. Accessing the configuration panel differs by component, but most can be identified with the gear icon. Refer to the specific component\u2019s documentation for instructions on how to exactly access its configuration panel. Configuration is only available for those users with the appropriate permission.","title":"Accessing a Configuration Panel"},{"location":"config/config-basics/#primary-configuration-area","text":"The primary configuration area on a configuration page is typically a 2-panel card. For example, tables have a configuration area where the list of available fields are selectable on the left and the configurable values are displayed on the right. [Screenshot of table configuration panel with each side outlined and labeled] The primary configuration may vary slightly depending on the UI component. For example, in the search bar configuration, the configuration area is a list of the searchable fields with checkboxes. [Screenshot of search bar configuration]","title":"Primary Configuration Area"},{"location":"config/config-basics/#versions","text":"A version is a saved configuration profile for an individual UI component. A user may use versions when experimenting with the configuration of a component before rolling it out to others. A version is specific to the user, in that no users can see another\u2019s user versions.","title":"Versions"},{"location":"config/config-basics/#create-a-version","text":"To create a version, use the Save To > Create Version button in the upper right of the configuration panel.","title":"Create A Version"},{"location":"config/config-basics/#save-a-version","text":"Once created, users can save their current component\u2019s configuration to the version by clicking Save To > Versions and selecting the version. Once saved, click Apply to apply the configuration to the component.","title":"Save A Version"},{"location":"config/config-basics/#load-a-version","text":"To retrieve a previously saved version, click the Load From button in the upper left of the configuration panel and select the desired version. This will load that version\u2019s configuration into the panel. Click Apply to the apply that version\u2019s configuration to the component. [Save To Screenshot] [Load From Screenshot]","title":"Load A Version"},{"location":"config/config-basics/#delete-a-version","text":"To delete a version, click the three dots icon next to Save To > Delete Versions , and select the version to delete. Confirm the deletion in the prompt.","title":"Delete A Version"},{"location":"config/config-basics/#configuring-a-page","text":"The high-level steps to configuring a page are: Pick the role and page : If the configured page is applicable to a specific role, assume the role using the role selector. Then, navigate to the page where the configuration should apply. Configure each component on the page : Refer to the UI component documentation as necessary Save the configured state to a dashboard : The dashboard can either be an existing or new dashboard. If new, specify where and to which users the dashboard can be shown as a selection option. Set the priority of the dashboards by setting defaults : once the dashboard is saved, determine when it should be shown to a user in relative priority to other dashboards already configured for the page","title":"Configuring a Page"},{"location":"config/config-basics/#pick-the-role-and-page","text":"It\u2019s common for an application to present data on the same page differently to users with different roles. For example, a field engineer may want to see the battery level and firmeware version of a device, while a customer service rep may want to see its last known location. If the configuration is applicable to a specific role, assume the role by selecting it from the role selector. Access the role selector by clicking the username in upper right of the page and selecting the role under User Role . [Screenshot of role selector] Navigate to the page to where the configuration should be applied. For example, if the configuration is intended for the Assets page, navigate to the Assets page. If the configuration is meant to be applied to an existing dashboard, load the dashboard by selecting it from the dashboard selector at the top of the page. [Screenshot of the dashboard selector]","title":"Pick the Role and Page"},{"location":"config/config-basics/#configure-each-component-on-the-page","text":"Use the layout controller to place the desired components on the page. Refer to the documentation for the layout controller for more details. [Screenshot of layout controller on the UI] For each component, access the control panel and make the desired configuration changes. Click Apply in the configuration panel of that component once all the desired changes are performed. Refer to the document for the specific component for more details.","title":"Configure Each Component on the Page"},{"location":"config/config-basics/#save-the-configured-state-to-a-dashboard","text":"Once all configuration to all components have been completed, a user can save the entire state of the page to a dashboard. To save the configured state to the current dashboard, click the check mark icon next to the dashboard selector. To revert the changes back to its previously saved state, click the reverse circle icon. [Screenshot of save & revert of current dashboard] Note: The Default dashboard is a user\u2019s personal dashboard configuration for exact page location. Saving the configuration to the dashboard titled \u201cDefault\u201d will only apply the configuration as the default dashboard to the current user, for currently assumed role, and to exact path for which the configuration was performed. For example, if a user A is on the Company > Assets page as Role A and saves a new configuration to the Default dashboard at that page, it will affect only the Default dashboard for User A while they are using Role A on the Company > Assets page. It will not impact the Default dashboard for user B at Company > Assets using Role A, not impact Default dashboard for any users at Company > Assets using Role B, and not impact the Default dashboard of user A at other Asset paths (e.g. Location > Assets) using Role A. To save the configured state to a new dashboard, click the three-dot icon next to the dashboard selector and click Save Dashboard As\u2026 In the Save Dashboard As\u2026 popup, enter the name of the new dashboard Select the availability of the dashboard from the Available To dropdown: Role Level - Any on this page: The option to select this dashboard will appear for any users of role X on this exact page path, with role X being the currently assumed role of the user doing the configuration. For example, only show this dashboard for users with Role A and on the Assets page at the Company > Assets path. This will create an option in the dropdown under the \u201cRole\u201d section of the dashboard selector. Page Level - Any user on this page: The option to select this dashboard will appear for any user of any role on this exact page path. For example, show this dashboard for all users on the Assets page at the Company > Assets path. This will create an option in the dropdown under the \u201cPage\u201d section. Blueprint Level - Any user on the page showing this page's Blueprint type: The option to select this dashboard will appear for any user of any role on a page of the same Blueprint type as the one being configured. For example, show this dashboard for all users on all Asset pages, regardless of its specific path. This will create an option in the dropdown under the section named after the Blueprint type (e.g. Assets). Personal Blueprint Level - Me on any page showing this page's Blueprint type: The option to select this dashboard will appear for only the current user on any page of any role on a page of the same Blueprint type as the one being configured. This will create an option in the dropdown under the \u201cMine\u201d section. Looking for an option to save the configured page to the current user for the current role and current path? Save the dashboard to the Default dashboard by click the check mark next to the left of the dashboard selector?","title":"Save the Configured State to a Dashboard"},{"location":"config/config-basics/#set-the-defaults-of-the-page","text":"The previous section on Saving the Dashboard produces a dashboard that is available for selection by a user on a give page. It does not yet specify whether it will load by default when a user visits that page. In order to apply the dashboard to pages so that it loads for given users, page locations, and roles, set the dashboard defaults. Click the three dots icon next to the dashboard selector to load the list of editable dashboards Depending on how many dashboards you have configured and their availability on the page, you will see dashboards separated into the following categories based on availability criteria: Role - Dashboards that are available to show on this page based on the user\u2019s role Page - Dashboards that are available to show on this page based on the user\u2019s page path in the application [Name of Blueprint Type] (e.g. Assets) - Dashboards that are available to show on this page based on the type of blueprint that page is showing Mine - Personal dashboards that are available to show on this page based on the type of blueprint that page is showing To set a dashboard to show by default on the page when it meets the availability criteria, select the dashboard > Use as Default . Only one dashboard from each section can be set as default (e.g. only one Role-level dashboard can be set as default, one Page-level dashboard can be set as default, etc.) In the event that multiple dashboards across each section is set as default, the application shows the default dashboard based on this ranking (from highest to lowest): Mine Role Page Blueprint Default","title":"Set the Defaults Of The Page"},{"location":"config/config-basics/#managing-dashboards","text":"","title":"Managing Dashboards"},{"location":"config/config-basics/#renaming-a-dashboard","text":"To rename a dashboard, click the three dots icon next to the dashboard selector and select the [dashboard name] > Rename .","title":"Renaming A Dashboard"},{"location":"config/config-basics/#delete-a-dashboard","text":"To delete a dashboard, click the three dots icon next to the dashboard selector and select the dashboard name > Delete . If the deleted dashboard was displayed on the page, the page will switch to showing the Default dashboard.","title":"Delete a Dashboard"},{"location":"config/config-basics/#reset-personal-default-dashboard-back-to-stock","text":"If the Default dashboard has been changed and a user wishes to reset it back to its original state (e.g. \u201cfactory defaults\u201d), select the Default dashboard from the dashboard selector. Then click the three dots icon next to the dashboard selector > Reset to Default Dashboard .","title":"Reset Personal Default Dashboard Back to Stock"},{"location":"config/config-basics/#configuration-best-practices","text":"We\u2019re working on making a list of best practices, stay tuned!","title":"Configuration Best Practices"},{"location":"config/tables/parents/","text":"Parent Data Columns in Tables \u00b6 Sometimes, you want to show the parent on the child table. You can see an example of this below, where the table is showing the parent location of the asset. In this guide, we'll show you how to set that up in your interface. Parent table column example To add and configure parent columns in the child blueprint's table, you can add metadata to the parent attribute on the child blueprint. Edit metadata of parent attribute For the setter metadata, there are two values you need to understand, path and sourcePath . Setter Value Description path The path of the current blueprint you are trying to configure the parent column for. Paths determine where you are in the UI looking at this blueprint. sourcePath The path of the parent you are trying to load into the chid table. For example, if your root is Location which has a one to many relationship with Assets and you are on the assets page in a given location, your path would be location.assets and your source path would be location . Whether you use singular or plural depends on the type of relationship. If it was a one-to-one relationship, your path would look like location.asset . Alternatively, if your root was company and company had a one-to-many relationship with locations while locations still had a one-to-many relationship with assets, your path and sourcePath would be company.locations.assets & company.locations respectively. For our final example, lets say both your location blueprint and asset blueprint are roots and you want to load the location column into the root-level asset page. In this case your path is asset and your source path is location . Both will be singular since they are roots. Metadata Example { \"setter\" : { \"parentSources\" : [ { \"path\" : \"location.assets\" , \"sourcePath\" : \"location\" }, { \"path\" : \"company.locations.assets\" , \"sourcePath\" : \"company.locations\" }, { \"path\" : \"asset\" , \"sourcePath\" : \"location\" } ] } } Copying Parent Attributes onto the Child \u00b6 Along with enabling the parent to show up in the child table, you can also copy attributes from the parent onto the child. Note that this only gets updated when a relationship is created. If the attribute is changed on the parent later, the copied value on the child does not update . Setter Value Description child Child represents the attribute on the child blueprint you want to copy the value to. The format should follow blueprint.attribute . Note that if you have your attributes in a group it may look like blueprint.group.attribute copyNull If the value is null, you can either copy the value by setting this to true or ignoring the value by setting this to false parent Parent represents the attribute from the parent blueprint you want to copy onto the child. The format is the same as the child value. Metadata Example { \"setter\" : { \"copyValues\" : [ { \"child\" : \"asset.address\" , \"copyNull\" : true , \"parent\" : \"location.address\" } ], } } Running Functions Against the Parent Value \u00b6 When copying the value from the parent, sometimes you want to run a function against it to get the correct child data. The two valid options for this are geoJsonCenter and geoJsonCenterOfMass , which are only usable with a parent geoShape value and a geoPoint child value. If type is not set, the parent value will be copied to the child. The types must be the same. Setter Value Description geoJsonCenter If you drew a box around the geoshape, this represents the center of that box. geoJsonCenterOfMass This represents the geometric center of the geoshape, the arithmetic mean position of all of the points in the figure. Center vs. Center of Mass A good use case example for this function is beacon installation into zones. When installing beacons, you might want them to automatically be placed in the center of a zone, in which case you would want to use type:geoShapeCenterOfMass { \"setter\" : { \"copyValues\" : [ { \"child\" : \"beacon.position\" , \"copyNull\" : false , \"parent\" : \"zone.area\" , \"type\" : \"geoShapeCenterOfMass\" } ] } }","title":"Parent Data Columns in Tables"},{"location":"config/tables/parents/#parent-data-columns-in-tables","text":"Sometimes, you want to show the parent on the child table. You can see an example of this below, where the table is showing the parent location of the asset. In this guide, we'll show you how to set that up in your interface. Parent table column example To add and configure parent columns in the child blueprint's table, you can add metadata to the parent attribute on the child blueprint. Edit metadata of parent attribute For the setter metadata, there are two values you need to understand, path and sourcePath . Setter Value Description path The path of the current blueprint you are trying to configure the parent column for. Paths determine where you are in the UI looking at this blueprint. sourcePath The path of the parent you are trying to load into the chid table. For example, if your root is Location which has a one to many relationship with Assets and you are on the assets page in a given location, your path would be location.assets and your source path would be location . Whether you use singular or plural depends on the type of relationship. If it was a one-to-one relationship, your path would look like location.asset . Alternatively, if your root was company and company had a one-to-many relationship with locations while locations still had a one-to-many relationship with assets, your path and sourcePath would be company.locations.assets & company.locations respectively. For our final example, lets say both your location blueprint and asset blueprint are roots and you want to load the location column into the root-level asset page. In this case your path is asset and your source path is location . Both will be singular since they are roots. Metadata Example { \"setter\" : { \"parentSources\" : [ { \"path\" : \"location.assets\" , \"sourcePath\" : \"location\" }, { \"path\" : \"company.locations.assets\" , \"sourcePath\" : \"company.locations\" }, { \"path\" : \"asset\" , \"sourcePath\" : \"location\" } ] } }","title":"Parent Data Columns in Tables"},{"location":"config/tables/parents/#copying-parent-attributes-onto-the-child","text":"Along with enabling the parent to show up in the child table, you can also copy attributes from the parent onto the child. Note that this only gets updated when a relationship is created. If the attribute is changed on the parent later, the copied value on the child does not update . Setter Value Description child Child represents the attribute on the child blueprint you want to copy the value to. The format should follow blueprint.attribute . Note that if you have your attributes in a group it may look like blueprint.group.attribute copyNull If the value is null, you can either copy the value by setting this to true or ignoring the value by setting this to false parent Parent represents the attribute from the parent blueprint you want to copy onto the child. The format is the same as the child value. Metadata Example { \"setter\" : { \"copyValues\" : [ { \"child\" : \"asset.address\" , \"copyNull\" : true , \"parent\" : \"location.address\" } ], } }","title":"Copying Parent Attributes onto the Child"},{"location":"config/tables/parents/#running-functions-against-the-parent-value","text":"When copying the value from the parent, sometimes you want to run a function against it to get the correct child data. The two valid options for this are geoJsonCenter and geoJsonCenterOfMass , which are only usable with a parent geoShape value and a geoPoint child value. If type is not set, the parent value will be copied to the child. The types must be the same. Setter Value Description geoJsonCenter If you drew a box around the geoshape, this represents the center of that box. geoJsonCenterOfMass This represents the geometric center of the geoshape, the arithmetic mean position of all of the points in the figure. Center vs. Center of Mass A good use case example for this function is beacon installation into zones. When installing beacons, you might want them to automatically be placed in the center of a zone, in which case you would want to use type:geoShapeCenterOfMass { \"setter\" : { \"copyValues\" : [ { \"child\" : \"beacon.position\" , \"copyNull\" : false , \"parent\" : \"zone.area\" , \"type\" : \"geoShapeCenterOfMass\" } ] } }","title":"Running Functions Against the Parent Value"},{"location":"config/tables/sorting/","text":"Configuration and Dashboard Basics \u00b6 Leverege Amplify provides users with the ability to configure the look, feel, and behavior of the vast majority of components in the application. Examples of components include tables, maps, rollover cards, and graphs. Configuring a page of the application relies on three primary steps: Configuring each component using its configuration panel . A configuration panel is a popup or screen where a user can configure and change settings of an individual component on a page Saving the components to a dashboard . A dashboard is a single view that arranges and displays all the components on the page Setting where and for whom the dashboard appears . By setting the dashboard availability and defaults, a user can specify on which pages and for which types of users the dashboard is seen. The following sections describe how to interact with configuration panel, save configured components to a dashboard, and administer a dashboard to be seen by either all or select users of an application. Accessing a Configuration Panel \u00b6 Each configurable component in the application is controlled by a configuration panel. All configuration panels share a similar layout and set of functions. Accessing the configuration panel differs by component, but most can be identified with the gear icon. Refer to the specific component\u2019s documentation for instructions on how to exactly access its configuration panel. Configuration is only available for those users with the appropriate permission. Primary Configuration Area \u00b6 The primary configuration area on a configuration page is typically a 2-panel card. For example, tables have a configuration area where the list of available fields are selectable on the left and the configurable values are displayed on the right. [Screenshot of table configuration panel with each side outlined and labeled] The primary configuration may vary slightly depending on the UI component. For example, in the search bar configuration, the configuration area is a list of the searchable fields with checkboxes. [Screenshot of search bar configuration] Versions \u00b6 A version is a saved configuration profile for an individual UI component. A user may use versions when experimenting with the configuration of a component before rolling it out to others. A version is specific to the user, in that no users can see another\u2019s user versions. Create A Version \u00b6 To create a version, use the Save To > Create Version button in the upper right of the configuration panel. Save A Version \u00b6 Once created, users can save their current component\u2019s configuration to the version by clicking Save To > Versions and selecting the version. Once saved, click Apply to apply the configuration to the component. Load A Version \u00b6 To retrieve a previously saved version, click the Load From button in the upper left of the configuration panel and select the desired version. This will load that version\u2019s configuration into the panel. Click Apply to the apply that version\u2019s configuration to the component. [Save To Screenshot] [Load From Screenshot] Delete A Version \u00b6 To delete a version, click the three dots icon next to Save To > Delete Versions , and select the version to delete. Confirm the deletion in the prompt. Configuring a Page \u00b6 The high-level steps to configuring a page are: Pick the role and page : If the configured page is applicable to a specific role, assume the role using the role selector. Then, navigate to the page where the configuration should apply. Configure each component on the page : Refer to the UI component documentation as necessary Save the configured state to a dashboard : The dashboard can either be an existing or new dashboard. If new, specify where and to which users the dashboard can be shown as a selection option. Set the priority of the dashboards by setting defaults : once the dashboard is saved, determine when it should be shown to a user in relative priority to other dashboards already configured for the page Pick the Role and Page \u00b6 It\u2019s common for an application to present data on the same page differently to users with different roles. For example, a field engineer may want to see the battery level and firmeware version of a device, while a customer service rep may want to see its last known location. If the configuration is applicable to a specific role, assume the role by selecting it from the role selector. Access the role selector by clicking the username in upper right of the page and selecting the role under User Role . [Screenshot of role selector] Navigate to the page to where the configuration should be applied. For example, if the configuration is intended for the Assets page, navigate to the Assets page. If the configuration is meant to be applied to an existing dashboard, load the dashboard by selecting it from the dashboard selector at the top of the page. [Screenshot of the dashboard selector] Configure Each Component on the Page \u00b6 Use the layout controller to place the desired components on the page. Refer to the documentation for the layout controller for more details. [Screenshot of layout controller on the UI] For each component, access the control panel and make the desired configuration changes. Click Apply in the configuration panel of that component once all the desired changes are performed. Refer to the document for the specific component for more details. Save the Configured State to a Dashboard \u00b6 Once all configuration to all components have been completed, a user can save the entire state of the page to a dashboard. To save the configured state to the current dashboard, click the check mark icon next to the dashboard selector. To revert the changes back to its previously saved state, click the reverse circle icon. [Screenshot of save & revert of current dashboard] Note: The Default dashboard is a user\u2019s personal dashboard configuration for exact page location. Saving the configuration to the dashboard titled \u201cDefault\u201d will only apply the configuration as the default dashboard to the current user, for currently assumed role, and to exact path for which the configuration was performed. For example, if a user A is on the Company > Assets page as Role A and saves a new configuration to the Default dashboard at that page, it will affect only the Default dashboard for User A while they are using Role A on the Company > Assets page. It will not impact the Default dashboard for user B at Company > Assets using Role A, not impact Default dashboard for any users at Company > Assets using Role B, and not impact the Default dashboard of user A at other Asset paths (e.g. Location > Assets) using Role A. To save the configured state to a new dashboard, click the three-dot icon next to the dashboard selector and click Save Dashboard As\u2026 In the Save Dashboard As\u2026 popup, enter the name of the new dashboard Select the availability of the dashboard from the Available To dropdown: Role Level - Any on this page: The option to select this dashboard will appear for any users of role X on this exact page path, with role X being the currently assumed role of the user doing the configuration. For example, only show this dashboard for users with Role A and on the Assets page at the Company > Assets path. This will create an option in the dropdown under the \u201cRole\u201d section of the dashboard selector. Page Level - Any user on this page: The option to select this dashboard will appear for any user of any role on this exact page path. For example, show this dashboard for all users on the Assets page at the Company > Assets path. This will create an option in the dropdown under the \u201cPage\u201d section. Blueprint Level - Any user on the page showing this page's Blueprint type: The option to select this dashboard will appear for any user of any role on a page of the same Blueprint type as the one being configured. For example, show this dashboard for all users on all Asset pages, regardless of its specific path. This will create an option in the dropdown under the section named after the Blueprint type (e.g. Assets). Personal Blueprint Level - Me on any page showing this page's Blueprint type: The option to select this dashboard will appear for only the current user on any page of any role on a page of the same Blueprint type as the one being configured. This will create an option in the dropdown under the \u201cMine\u201d section. Looking for an option to save the configured page to the current user for the current role and current path? Save the dashboard to the Default dashboard by click the check mark next to the left of the dashboard selector? Set the Defaults Of The Page \u00b6 The previous section on Saving the Dashboard produces a dashboard that is available for selection by a user on a give page. It does not yet specify whether it will load by default when a user visits that page. In order to apply the dashboard to pages so that it loads for given users, page locations, and roles, set the dashboard defaults. Click the three dots icon next to the dashboard selector to load the list of editable dashboards Depending on how many dashboards you have configured and their availability on the page, you will see dashboards separated into the following categories based on availability criteria: Role - Dashboards that are available to show on this page based on the user\u2019s role Page - Dashboards that are available to show on this page based on the user\u2019s page path in the application [Name of Blueprint Type] (e.g. Assets) - Dashboards that are available to show on this page based on the type of blueprint that page is showing Mine - Personal dashboards that are available to show on this page based on the type of blueprint that page is showing To set a dashboard to show by default on the page when it meets the availability criteria, select the dashboard > Use as Default . Only one dashboard from each section can be set as default (e.g. only one Role-level dashboard can be set as default, one Page-level dashboard can be set as default, etc.) In the event that multiple dashboards across each section is set as default, the application shows the default dashboard based on this ranking (from highest to lowest): Mine Role Page Blueprint Default Managing Dashboards \u00b6 Renaming A Dashboard \u00b6 To rename a dashboard, click the three dots icon next to the dashboard selector and select the [dashboard name] > Rename . Delete a Dashboard \u00b6 To delete a dashboard, click the three dots icon next to the dashboard selector and select the dashboard name > Delete . If the deleted dashboard was displayed on the page, the page will switch to showing the Default dashboard. Reset Personal Default Dashboard Back to Stock \u00b6 If the Default dashboard has been changed and a user wishes to reset it back to its original state (e.g. \u201cfactory defaults\u201d), select the Default dashboard from the dashboard selector. Then click the three dots icon next to the dashboard selector > Reset to Default Dashboard . Configuration Best Practices \u00b6 We\u2019re working on making a list of best practices, stay tuned!","title":"Configuration and Dashboard Basics"},{"location":"config/tables/sorting/#configuration-and-dashboard-basics","text":"Leverege Amplify provides users with the ability to configure the look, feel, and behavior of the vast majority of components in the application. Examples of components include tables, maps, rollover cards, and graphs. Configuring a page of the application relies on three primary steps: Configuring each component using its configuration panel . A configuration panel is a popup or screen where a user can configure and change settings of an individual component on a page Saving the components to a dashboard . A dashboard is a single view that arranges and displays all the components on the page Setting where and for whom the dashboard appears . By setting the dashboard availability and defaults, a user can specify on which pages and for which types of users the dashboard is seen. The following sections describe how to interact with configuration panel, save configured components to a dashboard, and administer a dashboard to be seen by either all or select users of an application.","title":"Configuration and Dashboard Basics"},{"location":"config/tables/sorting/#accessing-a-configuration-panel","text":"Each configurable component in the application is controlled by a configuration panel. All configuration panels share a similar layout and set of functions. Accessing the configuration panel differs by component, but most can be identified with the gear icon. Refer to the specific component\u2019s documentation for instructions on how to exactly access its configuration panel. Configuration is only available for those users with the appropriate permission.","title":"Accessing a Configuration Panel"},{"location":"config/tables/sorting/#primary-configuration-area","text":"The primary configuration area on a configuration page is typically a 2-panel card. For example, tables have a configuration area where the list of available fields are selectable on the left and the configurable values are displayed on the right. [Screenshot of table configuration panel with each side outlined and labeled] The primary configuration may vary slightly depending on the UI component. For example, in the search bar configuration, the configuration area is a list of the searchable fields with checkboxes. [Screenshot of search bar configuration]","title":"Primary Configuration Area"},{"location":"config/tables/sorting/#versions","text":"A version is a saved configuration profile for an individual UI component. A user may use versions when experimenting with the configuration of a component before rolling it out to others. A version is specific to the user, in that no users can see another\u2019s user versions.","title":"Versions"},{"location":"config/tables/sorting/#create-a-version","text":"To create a version, use the Save To > Create Version button in the upper right of the configuration panel.","title":"Create A Version"},{"location":"config/tables/sorting/#save-a-version","text":"Once created, users can save their current component\u2019s configuration to the version by clicking Save To > Versions and selecting the version. Once saved, click Apply to apply the configuration to the component.","title":"Save A Version"},{"location":"config/tables/sorting/#load-a-version","text":"To retrieve a previously saved version, click the Load From button in the upper left of the configuration panel and select the desired version. This will load that version\u2019s configuration into the panel. Click Apply to the apply that version\u2019s configuration to the component. [Save To Screenshot] [Load From Screenshot]","title":"Load A Version"},{"location":"config/tables/sorting/#delete-a-version","text":"To delete a version, click the three dots icon next to Save To > Delete Versions , and select the version to delete. Confirm the deletion in the prompt.","title":"Delete A Version"},{"location":"config/tables/sorting/#configuring-a-page","text":"The high-level steps to configuring a page are: Pick the role and page : If the configured page is applicable to a specific role, assume the role using the role selector. Then, navigate to the page where the configuration should apply. Configure each component on the page : Refer to the UI component documentation as necessary Save the configured state to a dashboard : The dashboard can either be an existing or new dashboard. If new, specify where and to which users the dashboard can be shown as a selection option. Set the priority of the dashboards by setting defaults : once the dashboard is saved, determine when it should be shown to a user in relative priority to other dashboards already configured for the page","title":"Configuring a Page"},{"location":"config/tables/sorting/#pick-the-role-and-page","text":"It\u2019s common for an application to present data on the same page differently to users with different roles. For example, a field engineer may want to see the battery level and firmeware version of a device, while a customer service rep may want to see its last known location. If the configuration is applicable to a specific role, assume the role by selecting it from the role selector. Access the role selector by clicking the username in upper right of the page and selecting the role under User Role . [Screenshot of role selector] Navigate to the page to where the configuration should be applied. For example, if the configuration is intended for the Assets page, navigate to the Assets page. If the configuration is meant to be applied to an existing dashboard, load the dashboard by selecting it from the dashboard selector at the top of the page. [Screenshot of the dashboard selector]","title":"Pick the Role and Page"},{"location":"config/tables/sorting/#configure-each-component-on-the-page","text":"Use the layout controller to place the desired components on the page. Refer to the documentation for the layout controller for more details. [Screenshot of layout controller on the UI] For each component, access the control panel and make the desired configuration changes. Click Apply in the configuration panel of that component once all the desired changes are performed. Refer to the document for the specific component for more details.","title":"Configure Each Component on the Page"},{"location":"config/tables/sorting/#save-the-configured-state-to-a-dashboard","text":"Once all configuration to all components have been completed, a user can save the entire state of the page to a dashboard. To save the configured state to the current dashboard, click the check mark icon next to the dashboard selector. To revert the changes back to its previously saved state, click the reverse circle icon. [Screenshot of save & revert of current dashboard] Note: The Default dashboard is a user\u2019s personal dashboard configuration for exact page location. Saving the configuration to the dashboard titled \u201cDefault\u201d will only apply the configuration as the default dashboard to the current user, for currently assumed role, and to exact path for which the configuration was performed. For example, if a user A is on the Company > Assets page as Role A and saves a new configuration to the Default dashboard at that page, it will affect only the Default dashboard for User A while they are using Role A on the Company > Assets page. It will not impact the Default dashboard for user B at Company > Assets using Role A, not impact Default dashboard for any users at Company > Assets using Role B, and not impact the Default dashboard of user A at other Asset paths (e.g. Location > Assets) using Role A. To save the configured state to a new dashboard, click the three-dot icon next to the dashboard selector and click Save Dashboard As\u2026 In the Save Dashboard As\u2026 popup, enter the name of the new dashboard Select the availability of the dashboard from the Available To dropdown: Role Level - Any on this page: The option to select this dashboard will appear for any users of role X on this exact page path, with role X being the currently assumed role of the user doing the configuration. For example, only show this dashboard for users with Role A and on the Assets page at the Company > Assets path. This will create an option in the dropdown under the \u201cRole\u201d section of the dashboard selector. Page Level - Any user on this page: The option to select this dashboard will appear for any user of any role on this exact page path. For example, show this dashboard for all users on the Assets page at the Company > Assets path. This will create an option in the dropdown under the \u201cPage\u201d section. Blueprint Level - Any user on the page showing this page's Blueprint type: The option to select this dashboard will appear for any user of any role on a page of the same Blueprint type as the one being configured. For example, show this dashboard for all users on all Asset pages, regardless of its specific path. This will create an option in the dropdown under the section named after the Blueprint type (e.g. Assets). Personal Blueprint Level - Me on any page showing this page's Blueprint type: The option to select this dashboard will appear for only the current user on any page of any role on a page of the same Blueprint type as the one being configured. This will create an option in the dropdown under the \u201cMine\u201d section. Looking for an option to save the configured page to the current user for the current role and current path? Save the dashboard to the Default dashboard by click the check mark next to the left of the dashboard selector?","title":"Save the Configured State to a Dashboard"},{"location":"config/tables/sorting/#set-the-defaults-of-the-page","text":"The previous section on Saving the Dashboard produces a dashboard that is available for selection by a user on a give page. It does not yet specify whether it will load by default when a user visits that page. In order to apply the dashboard to pages so that it loads for given users, page locations, and roles, set the dashboard defaults. Click the three dots icon next to the dashboard selector to load the list of editable dashboards Depending on how many dashboards you have configured and their availability on the page, you will see dashboards separated into the following categories based on availability criteria: Role - Dashboards that are available to show on this page based on the user\u2019s role Page - Dashboards that are available to show on this page based on the user\u2019s page path in the application [Name of Blueprint Type] (e.g. Assets) - Dashboards that are available to show on this page based on the type of blueprint that page is showing Mine - Personal dashboards that are available to show on this page based on the type of blueprint that page is showing To set a dashboard to show by default on the page when it meets the availability criteria, select the dashboard > Use as Default . Only one dashboard from each section can be set as default (e.g. only one Role-level dashboard can be set as default, one Page-level dashboard can be set as default, etc.) In the event that multiple dashboards across each section is set as default, the application shows the default dashboard based on this ranking (from highest to lowest): Mine Role Page Blueprint Default","title":"Set the Defaults Of The Page"},{"location":"config/tables/sorting/#managing-dashboards","text":"","title":"Managing Dashboards"},{"location":"config/tables/sorting/#renaming-a-dashboard","text":"To rename a dashboard, click the three dots icon next to the dashboard selector and select the [dashboard name] > Rename .","title":"Renaming A Dashboard"},{"location":"config/tables/sorting/#delete-a-dashboard","text":"To delete a dashboard, click the three dots icon next to the dashboard selector and select the dashboard name > Delete . If the deleted dashboard was displayed on the page, the page will switch to showing the Default dashboard.","title":"Delete a Dashboard"},{"location":"config/tables/sorting/#reset-personal-default-dashboard-back-to-stock","text":"If the Default dashboard has been changed and a user wishes to reset it back to its original state (e.g. \u201cfactory defaults\u201d), select the Default dashboard from the dashboard selector. Then click the three dots icon next to the dashboard selector > Reset to Default Dashboard .","title":"Reset Personal Default Dashboard Back to Stock"},{"location":"config/tables/sorting/#configuration-best-practices","text":"We\u2019re working on making a list of best practices, stay tuned!","title":"Configuration Best Practices"},{"location":"features/","text":"","title":"Index"},{"location":"features/account/authentication/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Two-Step Verification"},{"location":"features/account/authentication/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/account/authentication/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/account/roles/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Multi-Role Management"},{"location":"features/account/roles/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/account/roles/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/account/signincode/","text":"One-Time Access Code \u00b6 The one-time access code feature is enabled or disabled at the project level. If the feature is enabled, any user registered in our system can request a one-time access code via the email address associated with their account. The code can be sent via email or text, as long as the user has a phone number tied to their account. The one-time access code button can be found on the login screen (image below). Login Screen An example of the email is below. If you want to customize your email, review our email configuration & styling help guide. Access Code Email","title":"One-Time Access Code"},{"location":"features/account/signincode/#one-time-access-code","text":"The one-time access code feature is enabled or disabled at the project level. If the feature is enabled, any user registered in our system can request a one-time access code via the email address associated with their account. The code can be sent via email or text, as long as the user has a phone number tied to their account. The one-time access code button can be found on the login screen (image below). Login Screen An example of the email is below. If you want to customize your email, review our email configuration & styling help guide. Access Code Email","title":"One-Time Access Code"},{"location":"features/create/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/create/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/create/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/fota/","text":"Introduction to FOTA \u00b6 Firmware Component: A firmware component is a software program for a specific processor inside the hardware. Your hardware will generally have 2 or more components. Some common components are below. MCU: Main Processor Logic BLE: Bluetooth/Wifi Logic Firmware Application: A firmware application contains programs for all three components. Each component is versioned. The firmware application is also versioned. This concept is similar to the iOS version running on your iPhone. Device Type: The device type is the model of the hardware.Firmware applications are specific to a single device type, as one may have components that another device type does not. This concept is similar to an iPhone 4 vs an iPhone 5. Device Group: A device group is a subset of devices at a given blueprint (i.e. location) with the same device type. How Does It Work? \u00b6 The FOTA server manages the firmware upgrades of the hardware in the system. Every heartbeat, the device will check whether there is a firmware application upgrade available via the FOTA server. From there, if a firmware application update is available, the FOTA server attempts to upgrade the device to the latest firmware application version. The FOTA server will only attempt to upgrade one component at a time. Note that firmware application upgrade paths only allow for one component to be different between applications. If successful, it updates the firmware application. If unsuccessful, the device can attempt to upgrade again. The amount of times the device retries is configurable per device type and the default is 3. If the device reaches the maximum amount of retries and has still not upgraded, the upgrade is stopped and marked as failed. Note that the maximum amount of retries applies to a single firmware application upgrade. If the device has to upgrade through multiple versions, each one will have a limit of retries equivalent to the configured amount per device type. The steps the FOTA server takes to check if the device should upgrade to a new firmware application are the following. If any of the below checks evaluate to false, the FOTA server does not upgrade the device: Is there an active release? Is the device\u2019s firmware already up to date? Has the device exceeded the maximum amount of retries? If upgrading outside of business hours is enabled, is the current time outside of business hours? If limiting concurrent upgrades is enabled, is there an open seat for this device? If stale device removal is enabled, are any of the devices currently upgrading \u201cstale\u201d? If so, this device will replace the stale device If the upgrade is set to a percentage of devices <100%, has this upgrade already been applied to the set percentage? Is there an upgrade path for this device to get from it\u2019s current firmware application version to the one set in the release?","title":"Introduction to FOTA"},{"location":"features/fota/#introduction-to-fota","text":"Firmware Component: A firmware component is a software program for a specific processor inside the hardware. Your hardware will generally have 2 or more components. Some common components are below. MCU: Main Processor Logic BLE: Bluetooth/Wifi Logic Firmware Application: A firmware application contains programs for all three components. Each component is versioned. The firmware application is also versioned. This concept is similar to the iOS version running on your iPhone. Device Type: The device type is the model of the hardware.Firmware applications are specific to a single device type, as one may have components that another device type does not. This concept is similar to an iPhone 4 vs an iPhone 5. Device Group: A device group is a subset of devices at a given blueprint (i.e. location) with the same device type.","title":"Introduction to FOTA"},{"location":"features/fota/#how-does-it-work","text":"The FOTA server manages the firmware upgrades of the hardware in the system. Every heartbeat, the device will check whether there is a firmware application upgrade available via the FOTA server. From there, if a firmware application update is available, the FOTA server attempts to upgrade the device to the latest firmware application version. The FOTA server will only attempt to upgrade one component at a time. Note that firmware application upgrade paths only allow for one component to be different between applications. If successful, it updates the firmware application. If unsuccessful, the device can attempt to upgrade again. The amount of times the device retries is configurable per device type and the default is 3. If the device reaches the maximum amount of retries and has still not upgraded, the upgrade is stopped and marked as failed. Note that the maximum amount of retries applies to a single firmware application upgrade. If the device has to upgrade through multiple versions, each one will have a limit of retries equivalent to the configured amount per device type. The steps the FOTA server takes to check if the device should upgrade to a new firmware application are the following. If any of the below checks evaluate to false, the FOTA server does not upgrade the device: Is there an active release? Is the device\u2019s firmware already up to date? Has the device exceeded the maximum amount of retries? If upgrading outside of business hours is enabled, is the current time outside of business hours? If limiting concurrent upgrades is enabled, is there an open seat for this device? If stale device removal is enabled, are any of the devices currently upgrading \u201cstale\u201d? If so, this device will replace the stale device If the upgrade is set to a percentage of devices <100%, has this upgrade already been applied to the set percentage? Is there an upgrade path for this device to get from it\u2019s current firmware application version to the one set in the release?","title":"How Does It Work?"},{"location":"features/fota/application/","text":"Firmware Application & Component Management \u00b6 Creating Firmware Component Versions \u00b6 Each firmware component has its own set of data fields that are required to create a new firmware component version. An example of the types of data each component has are below. Firmware Component Data Fields Device Type Type (MCU, BLE, etc) Semantic Version Component Specific Data Fields Creating Firmware Application Versions \u00b6 To create a new version of the firmware application, the user defines the following information Firmware Application Data Fields Device Type Semantic Version Components BLE Component Version MCU Component Version etc Dependency (Upgrade Path) Dependency (Upgrade Path) \u00b6 Every firmware application version has a dependency entry field that is filled out when the firmware application version is created. This field tells the system what the upgrade path for this specific application version is. Real examples of what this looks like are below. Example 1 \u00b6 Firmware Application Version 0.2.0 Dependency: >= 0.1.0 The above example is saying that to upgrade to version 0.2.0, the version currently running on the hardware must be greater than or equal to version 0.1.0. Example 2 \u00b6 Firmware Application Version 0.8.0 Dependency: >=0.3.0 < 0.6.0 || >=0.7.0 The above example is saying that to upgrade to version 0.8.0, the version currently running on the hardware must be (1) greater than or equal to version 0.3.0 and less than version 0.6.0 or (2) greater than or equal to version 0.7.0. Upgrade Path Requirements \u00b6 In order to move devices between applications, there are some limitations, outlined below. There can only be one component type difference between consecutive applications a device can upgrade through. This serves to limit the risk inherent in the firmware upgrades. We can skip component versions of the same component type, resulting in the ability to jump firmware application versions as shown by Example 2 above.","title":"Applications & Components"},{"location":"features/fota/application/#firmware-application-component-management","text":"","title":"Firmware Application &amp; Component Management"},{"location":"features/fota/application/#creating-firmware-component-versions","text":"Each firmware component has its own set of data fields that are required to create a new firmware component version. An example of the types of data each component has are below. Firmware Component Data Fields Device Type Type (MCU, BLE, etc) Semantic Version Component Specific Data Fields","title":"Creating Firmware Component Versions"},{"location":"features/fota/application/#creating-firmware-application-versions","text":"To create a new version of the firmware application, the user defines the following information Firmware Application Data Fields Device Type Semantic Version Components BLE Component Version MCU Component Version etc Dependency (Upgrade Path)","title":"Creating Firmware Application Versions"},{"location":"features/fota/application/#dependency-upgrade-path","text":"Every firmware application version has a dependency entry field that is filled out when the firmware application version is created. This field tells the system what the upgrade path for this specific application version is. Real examples of what this looks like are below.","title":"Dependency (Upgrade Path)"},{"location":"features/fota/application/#example-1","text":"Firmware Application Version 0.2.0 Dependency: >= 0.1.0 The above example is saying that to upgrade to version 0.2.0, the version currently running on the hardware must be greater than or equal to version 0.1.0.","title":"Example 1"},{"location":"features/fota/application/#example-2","text":"Firmware Application Version 0.8.0 Dependency: >=0.3.0 < 0.6.0 || >=0.7.0 The above example is saying that to upgrade to version 0.8.0, the version currently running on the hardware must be (1) greater than or equal to version 0.3.0 and less than version 0.6.0 or (2) greater than or equal to version 0.7.0.","title":"Example 2"},{"location":"features/fota/application/#upgrade-path-requirements","text":"In order to move devices between applications, there are some limitations, outlined below. There can only be one component type difference between consecutive applications a device can upgrade through. This serves to limit the risk inherent in the firmware upgrades. We can skip component versions of the same component type, resulting in the ability to jump firmware application versions as shown by Example 2 above.","title":"Upgrade Path Requirements"},{"location":"features/fota/release/","text":"Firmware Application Releases \u00b6 Firmware applications are released to a set of device groups for a single device type. Note that to release a firmware application to a device group, the firmware application must already exist in the system. Steps to Create a Firmware Application Release \u00b6 Select the device group(s) to release a new firmware application Select the device type Select the firmware application version that will be released Configure the below options Set the start time of the firmware application release Enable or disable upgrades outside of business hours Enable or disable concurrent upgrade limits Set the percentage of locators to include in the release Business Hours: If a given group has business hours, a release can either be scheduled outside of those business hours or continuous. This is to reduce the risk of disrupting business operations. Concurrent Upgrade Limit: The concurrent upgrade limit represents how many devices can upgrade their firmware in a device group at the same time. This number is set at the device type, then can be overridden at the device group level and while creating a release. Percentage of Devices to Upgrade: The user can set the percentage of devices to upgrade for a given release. If you set the release to 10% initially, you can edit this release at a later date to release to 20%. Firmware Application Release States \u00b6 Scheduled: The firmware application release is scheduled, but the start time is in the future Active: The firmware application release is active at a given device group. The release will remain active until it is paused or cancelled, even if all devices in the group have upgraded. This is because if you add more devices to a group, you will want them to upgrade to this firmware version. Paused: The firmware application is paused. Devices will not upgrade their firmware, but the firmware application release remains as the production release at this group. Resuming the firmware application sets the state back to active. Ended: The firmware application has ended for a given group. To upgrade firmware application versions at this group, a new release has to be made.","title":"FOTA Releases"},{"location":"features/fota/release/#firmware-application-releases","text":"Firmware applications are released to a set of device groups for a single device type. Note that to release a firmware application to a device group, the firmware application must already exist in the system.","title":"Firmware Application Releases"},{"location":"features/fota/release/#steps-to-create-a-firmware-application-release","text":"Select the device group(s) to release a new firmware application Select the device type Select the firmware application version that will be released Configure the below options Set the start time of the firmware application release Enable or disable upgrades outside of business hours Enable or disable concurrent upgrade limits Set the percentage of locators to include in the release Business Hours: If a given group has business hours, a release can either be scheduled outside of those business hours or continuous. This is to reduce the risk of disrupting business operations. Concurrent Upgrade Limit: The concurrent upgrade limit represents how many devices can upgrade their firmware in a device group at the same time. This number is set at the device type, then can be overridden at the device group level and while creating a release. Percentage of Devices to Upgrade: The user can set the percentage of devices to upgrade for a given release. If you set the release to 10% initially, you can edit this release at a later date to release to 20%.","title":"Steps to Create a Firmware Application Release"},{"location":"features/fota/release/#firmware-application-release-states","text":"Scheduled: The firmware application release is scheduled, but the start time is in the future Active: The firmware application release is active at a given device group. The release will remain active until it is paused or cancelled, even if all devices in the group have upgraded. This is because if you add more devices to a group, you will want them to upgrade to this firmware version. Paused: The firmware application is paused. Devices will not upgrade their firmware, but the firmware application release remains as the production release at this group. Resuming the firmware application sets the state back to active. Ended: The firmware application has ended for a given group. To upgrade firmware application versions at this group, a new release has to be made.","title":"Firmware Application Release States"},{"location":"features/fota/type/","text":"Device Type \u00b6 Every firmware component and application is device type-specific. There are multiple configurations set at this level, which are outlined below. Max Retry Number \u00b6 The max number of times a device will get sent the \u201cstartFota\u201d command after upgrade errors have been reported. This number can be overridden at the device group level or at the device level. Concurrent Device Upgrade Limit Per Device Group \u00b6 For a given device type, you can set the maximum number of devices in a device group that can be upgrading firmware at the same time. The purpose of this feature is to reduce the load on nearby cell towers by doing too many firmware upgrades at once. This can be overridden at the device group level. For example, if the limit is set so that 10 devices in a device group can upgrade at once, an override can be set so 30 devices in a specific group can upgrade at once. Stale Device Removal \u00b6 If this option is enabled, and all concurrent upgrade seats are filled, devices that have been upgrading for longer than the max upgrade duration will lose their upgrade seat. When devices lose their upgrade seat, the upgrade timeout is reported as an error on the device. This error is counted in the maximum amount of retries a device has for FOTA upgrades. This can be overridden at the device group level. Reporting Same Firmware Application While Upgrading Handled As Error \u00b6 If this option is enabled, and if a device reports the same firmware application while in an upgrading state, it will be assumed the device failed to report an error and a generic error will be reported on the device. This error is counted in the maximum amount of retries a device has for FOTA upgrades.","title":"Device Type"},{"location":"features/fota/type/#device-type","text":"Every firmware component and application is device type-specific. There are multiple configurations set at this level, which are outlined below.","title":"Device Type"},{"location":"features/fota/type/#max-retry-number","text":"The max number of times a device will get sent the \u201cstartFota\u201d command after upgrade errors have been reported. This number can be overridden at the device group level or at the device level.","title":"Max Retry Number"},{"location":"features/fota/type/#concurrent-device-upgrade-limit-per-device-group","text":"For a given device type, you can set the maximum number of devices in a device group that can be upgrading firmware at the same time. The purpose of this feature is to reduce the load on nearby cell towers by doing too many firmware upgrades at once. This can be overridden at the device group level. For example, if the limit is set so that 10 devices in a device group can upgrade at once, an override can be set so 30 devices in a specific group can upgrade at once.","title":"Concurrent Device Upgrade Limit Per Device Group"},{"location":"features/fota/type/#stale-device-removal","text":"If this option is enabled, and all concurrent upgrade seats are filled, devices that have been upgrading for longer than the max upgrade duration will lose their upgrade seat. When devices lose their upgrade seat, the upgrade timeout is reported as an error on the device. This error is counted in the maximum amount of retries a device has for FOTA upgrades. This can be overridden at the device group level.","title":"Stale Device Removal"},{"location":"features/fota/type/#reporting-same-firmware-application-while-upgrading-handled-as-error","text":"If this option is enabled, and if a device reports the same firmware application while in an upgrading state, it will be assumed the device failed to report an error and a generic error will be reported on the device. This error is counted in the maximum amount of retries a device has for FOTA upgrades.","title":"Reporting Same Firmware Application While Upgrading Handled As Error"},{"location":"features/map/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/map/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/map/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/map/multifloor/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Multi-Floor Management"},{"location":"features/map/multifloor/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/map/multifloor/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/map/zone/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Zones"},{"location":"features/map/zone/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/map/zone/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/pair/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/pair/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/pair/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/search/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/search/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/search/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/search/quicksearch/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Quick Search"},{"location":"features/search/quicksearch/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/search/quicksearch/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/users/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/users/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/users/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"getting-started/","text":"Getting Started \u00b6 Doc index.md","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Doc index.md","title":"Getting Started"},{"location":"getting-started/i18n/","text":"Localization \u00b6 i18n.md Installing Bundler \u00b6 Checking for translations \u00b6","title":"Localization"},{"location":"getting-started/i18n/#localization","text":"i18n.md","title":"Localization"},{"location":"getting-started/i18n/#installing-bundler","text":"","title":"Installing Bundler"},{"location":"getting-started/i18n/#checking-for-translations","text":"","title":"Checking for translations"},{"location":"intro/","text":"API \u00b6 Api Referenece","title":"API"},{"location":"intro/#api","text":"Api Referenece","title":"API"},{"location":"setup/","text":"UI Setup Overview \u00b6 In this section, we will be covering how to update the Style & Brand of your UI Create & Sort the Navigation Additional Options Available via Development This Section is for Pre-Created Projects If you have not already created your blueprints, relationships, and roles, please review our data architecture section to get started","title":"UI Setup Overview"},{"location":"setup/#ui-setup-overview","text":"In this section, we will be covering how to update the Style & Brand of your UI Create & Sort the Navigation Additional Options Available via Development This Section is for Pre-Created Projects If you have not already created your blueprints, relationships, and roles, please review our data architecture section to get started","title":"UI Setup Overview"},{"location":"setup/dev/","text":"Developer Options \u00b6 Developers have more UI setup options available in the config file for the UI. You can review the complete guide to what developers can [configure here] (https://leverege-steve-molten-docs.web.app/config/). Some developer configuration options include: Configuration: Hiding configuration tools from end-users 404 Screen: Changing the copy & illustrations on the 404 screen Network Offline Alert: Changing the copy and icon of the network offline alert Blueprint Action Icons: Changing the create, bulk create, remove, and edit icons User Management: Change different labels & description text within the user management plugin (ie renaming username to account email)","title":"Overview"},{"location":"setup/dev/#developer-options","text":"Developers have more UI setup options available in the config file for the UI. You can review the complete guide to what developers can [configure here] (https://leverege-steve-molten-docs.web.app/config/). Some developer configuration options include: Configuration: Hiding configuration tools from end-users 404 Screen: Changing the copy & illustrations on the 404 screen Network Offline Alert: Changing the copy and icon of the network offline alert Blueprint Action Icons: Changing the create, bulk create, remove, and edit icons User Management: Change different labels & description text within the user management plugin (ie renaming username to account email)","title":"Developer Options"},{"location":"setup/attributes/","text":"Attributes \u00b6","title":"Attributes"},{"location":"setup/attributes/#attributes","text":"","title":"Attributes"},{"location":"setup/attributes/data-sources/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"setup/attributes/data-sources/#data-sources","text":"","title":"Data Sources"},{"location":"setup/attributes/details/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"setup/attributes/details/#data-sources","text":"","title":"Data Sources"},{"location":"setup/attributes/formatters/","text":"Formatters \u00b6","title":"Formatters"},{"location":"setup/attributes/formatters/#formatters","text":"","title":"Formatters"},{"location":"setup/attributes/graph/","text":"Graphing \u00b6","title":"Graphing"},{"location":"setup/attributes/graph/#graphing","text":"","title":"Graphing"},{"location":"setup/attributes/relationships/","text":"Relationships \u00b6","title":"Relationships"},{"location":"setup/attributes/relationships/#relationships","text":"","title":"Relationships"},{"location":"setup/attributes/table/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"setup/attributes/table/#data-sources","text":"","title":"Data Sources"},{"location":"setup/branding/","text":"Branding \u00b6 The Leverege Stack makes customizing the end-user interfaces and emails to your brand very simple. In this section, we'll cover how you can use the UI builder, our global theming engine, and our email/text templates to ensure that your product is visually stunning. UI Theme \u00b6 The UI Builder is a stand-alone tool that allows you to edit & update the CSS theme of all UI elements in real time on your development site. This empowers you to change everything from a button color to the flex direction of a pane, all in one place. UI Inspector \u00b6 In your interfaces, you can turn on the UI inspector, which tells you what variant in the UI builder you are looking at. This allows you to quickly identify and update a given style of a css variant of a UI element. Logos & Branding \u00b6 It's easy to swap in and out different logos in your UIs using the UI Builder. Read our detailed instructions in the logos section. Icons \u00b6 We provide ample opportunity to customize icons. Customize your map icons, navigation icons, title bar icons, and more. Email & SMS Templates \u00b6 You don't have to start from scratch with your notifications. We provide 7 email templates and 3 SMS templates out of the box and provide an easy handlebar editor so you can make any customization you'd like. Empty States & Illustrations \u00b6 When a user is just starting out, it's helpful to guide them through the experience with clear directions and help links. A little illustration here or there never hurt anyone either.","title":"Branding"},{"location":"setup/branding/#branding","text":"The Leverege Stack makes customizing the end-user interfaces and emails to your brand very simple. In this section, we'll cover how you can use the UI builder, our global theming engine, and our email/text templates to ensure that your product is visually stunning.","title":"Branding"},{"location":"setup/branding/#ui-theme","text":"The UI Builder is a stand-alone tool that allows you to edit & update the CSS theme of all UI elements in real time on your development site. This empowers you to change everything from a button color to the flex direction of a pane, all in one place.","title":"UI Theme"},{"location":"setup/branding/#ui-inspector","text":"In your interfaces, you can turn on the UI inspector, which tells you what variant in the UI builder you are looking at. This allows you to quickly identify and update a given style of a css variant of a UI element.","title":"UI Inspector"},{"location":"setup/branding/#logos-branding","text":"It's easy to swap in and out different logos in your UIs using the UI Builder. Read our detailed instructions in the logos section.","title":"Logos &amp; Branding"},{"location":"setup/branding/#icons","text":"We provide ample opportunity to customize icons. Customize your map icons, navigation icons, title bar icons, and more.","title":"Icons"},{"location":"setup/branding/#email-sms-templates","text":"You don't have to start from scratch with your notifications. We provide 7 email templates and 3 SMS templates out of the box and provide an easy handlebar editor so you can make any customization you'd like.","title":"Email &amp; SMS Templates"},{"location":"setup/branding/#empty-states-illustrations","text":"When a user is just starting out, it's helpful to guide them through the experience with clear directions and help links. A little illustration here or there never hurt anyone either.","title":"Empty States &amp; Illustrations"},{"location":"setup/branding/builder/","text":"UI Builder Overview \u00b6 The UI Builder is an application that empowers users with the ability to style UI elements and make visual changes to UI elements in-real time. UI Builder is aimed at designers and other non-technical users to be able to make UI style changes quickly. By making UI style changes through UI Builder, users do not need to know how to code, manipulate HTML/CSS, or redeploy a project. Designers can make styling changes independently of engineers building out the application. This reduces the need to ask engineers to make styling changes and shortens the communication loop. Active Themes Active themes should only be used on dev environments. In your staging and production environments, engineers will export the theme during the deployment so that it is \"static\". This ensures that designers do not accidentally turn an entire production interface pink, for example. Navigating the UI Builder \u00b6 Every project has it's own UI builder project associated with it. If a given project has multiple UIs, a single UI builder project can be used for multiple UIs or each UI can use a unique UI builder project. UI Builder projects are organized by the type of UI element you are editing. You can find the categories down the left side of the project. UI Builder Project When a user clicks into a specific UI element, they can visually see an example of the UI element and can manually update nearly every aspect of it (e.g. color, padding, borders, hover states etc.). Any changes they make to the element are live changes to the development UI. UI Builder Element Editor Variants \u00b6 Each UI type has variations of that element called variants. A variant is a way to reuse the style of a given element in multiple places. For example, if a designer wants to use the same style button on two different places in the UI, they would use the same variant and any changes made to that variant on UI Builder will update both of those buttons. This means that all the designer has to do is specify to the engineer that a given button should inherit a given variant. It also means the engineer can code/place the button and the designer can then use the UI builder to fine tune how it looks. For some components, the variant can be specified in configuration panel of the UI component itself rather than needing to communicate it to the engineer. Creating a New Variant \u00b6 Create a variant by clicking the type of UI element in the left navigation. Then scroll to the bottom of the page and enter in the name of the variant in Variant field and press the + button. Configure the variant in the resulting right hand panel. Adding a new variant Variant Inheritance \u00b6 When creating a new variant, you very rarely need to start from scratch. Let's say you already built your primary button, but now you just need an icon version. Instead of rebuilding all of your styles, you can set your new primaryIconic button to inherit all of the default values from the primary button. Once you set that up, you can add in any overrides you need, maybe the width or border-radius for example. Adding a new variant","title":"UI Theme"},{"location":"setup/branding/builder/#ui-builder-overview","text":"The UI Builder is an application that empowers users with the ability to style UI elements and make visual changes to UI elements in-real time. UI Builder is aimed at designers and other non-technical users to be able to make UI style changes quickly. By making UI style changes through UI Builder, users do not need to know how to code, manipulate HTML/CSS, or redeploy a project. Designers can make styling changes independently of engineers building out the application. This reduces the need to ask engineers to make styling changes and shortens the communication loop. Active Themes Active themes should only be used on dev environments. In your staging and production environments, engineers will export the theme during the deployment so that it is \"static\". This ensures that designers do not accidentally turn an entire production interface pink, for example.","title":"UI Builder Overview"},{"location":"setup/branding/builder/#navigating-the-ui-builder","text":"Every project has it's own UI builder project associated with it. If a given project has multiple UIs, a single UI builder project can be used for multiple UIs or each UI can use a unique UI builder project. UI Builder projects are organized by the type of UI element you are editing. You can find the categories down the left side of the project. UI Builder Project When a user clicks into a specific UI element, they can visually see an example of the UI element and can manually update nearly every aspect of it (e.g. color, padding, borders, hover states etc.). Any changes they make to the element are live changes to the development UI. UI Builder Element Editor","title":"Navigating the UI Builder"},{"location":"setup/branding/builder/#variants","text":"Each UI type has variations of that element called variants. A variant is a way to reuse the style of a given element in multiple places. For example, if a designer wants to use the same style button on two different places in the UI, they would use the same variant and any changes made to that variant on UI Builder will update both of those buttons. This means that all the designer has to do is specify to the engineer that a given button should inherit a given variant. It also means the engineer can code/place the button and the designer can then use the UI builder to fine tune how it looks. For some components, the variant can be specified in configuration panel of the UI component itself rather than needing to communicate it to the engineer.","title":"Variants"},{"location":"setup/branding/builder/#creating-a-new-variant","text":"Create a variant by clicking the type of UI element in the left navigation. Then scroll to the bottom of the page and enter in the name of the variant in Variant field and press the + button. Configure the variant in the resulting right hand panel. Adding a new variant","title":"Creating a New Variant"},{"location":"setup/branding/builder/#variant-inheritance","text":"When creating a new variant, you very rarely need to start from scratch. Let's say you already built your primary button, but now you just need an icon version. Instead of rebuilding all of your styles, you can set your new primaryIconic button to inherit all of the default values from the primary button. Once you set that up, you can add in any overrides you need, maybe the width or border-radius for example. Adding a new variant","title":"Variant Inheritance"},{"location":"setup/branding/empty-states/","text":"Empty States & Illustrations \u00b6 No one likes a blank screen. That's why we've given you the ability to add helpful text hints, illustrations, and help links to the different empty states users might come across in the UI. Edit blueprint metadata in the info tab No Data to Load \u00b6 When your users are just starting out with your UI and they haven't added any data yet, they may need some help to guide them in the right direction. That's why we've given you the ability to configure the empty states of certain components, like the table & card list. You can make these changes for a given blueprint in the blueprint's metadata. Configuration options Metadata Example { \"strings\" : { \"noDataTitle\" : \"Add Your Assets\" , \"noDataBody\" : \"Ready to import your asset inventory? Upload your assets in bulk or individually.\" , \"noDataDocLink\" : \"https://www.google.com/\" }, \"icons\" : { \"noData\" : \"https://molten-ui-assets.storage.googleapis.com/no-data.svg\" } } No Search Results \u00b6 Sometimes your user searches for something that just doesn't exist. To help them along the way, and account for any special search and filter behaviors you might have in your application, you can customize your empty search results table & list message per blueprint. Configuration options Metadata Example { \"strings\" : { \"noSearchResultsTitle\" : \"We Couldn't Find Any Matches For That\" , \"noSearchResultsBody\" : \"Please try another search query.\" , }, \"icons\" : { \"noSearchResults\" : \"https://molten-ui-assets.storage.googleapis.com/no-search-results.svg\" } } SVG files will have the best resolution","title":"Empty States"},{"location":"setup/branding/empty-states/#empty-states-illustrations","text":"No one likes a blank screen. That's why we've given you the ability to add helpful text hints, illustrations, and help links to the different empty states users might come across in the UI. Edit blueprint metadata in the info tab","title":"Empty States &amp; Illustrations"},{"location":"setup/branding/empty-states/#no-data-to-load","text":"When your users are just starting out with your UI and they haven't added any data yet, they may need some help to guide them in the right direction. That's why we've given you the ability to configure the empty states of certain components, like the table & card list. You can make these changes for a given blueprint in the blueprint's metadata. Configuration options Metadata Example { \"strings\" : { \"noDataTitle\" : \"Add Your Assets\" , \"noDataBody\" : \"Ready to import your asset inventory? Upload your assets in bulk or individually.\" , \"noDataDocLink\" : \"https://www.google.com/\" }, \"icons\" : { \"noData\" : \"https://molten-ui-assets.storage.googleapis.com/no-data.svg\" } }","title":"No Data to Load"},{"location":"setup/branding/empty-states/#no-search-results","text":"Sometimes your user searches for something that just doesn't exist. To help them along the way, and account for any special search and filter behaviors you might have in your application, you can customize your empty search results table & list message per blueprint. Configuration options Metadata Example { \"strings\" : { \"noSearchResultsTitle\" : \"We Couldn't Find Any Matches For That\" , \"noSearchResultsBody\" : \"Please try another search query.\" , }, \"icons\" : { \"noSearchResults\" : \"https://molten-ui-assets.storage.googleapis.com/no-search-results.svg\" } } SVG files will have the best resolution","title":"No Search Results"},{"location":"setup/branding/icons/","text":"Icon Configuration \u00b6 There are many situations where you will want to customize your icons, whether they are for your navigation, map, headers, or lists. This is easily accomplished by adding metadata via Architect. Before following along, please ensure you have access to our Architect UI. Edit blueprint metadata in the info tab Storing Icons Prior to any of this configuration, the icons must be uploaded to the cloud and hosted publically. We suggest using GCP for this step. You also must know the URL of each icon state. Map Icons \u00b6 The metadata for map icons are found under the mapbox property, which is further subdivided by the icon state. Supported icon types for the map include your default icons (normal, rollover, selected, rollover-selected) and your historical point icons (history, history-rollover, history-selected). Format: PNG Current Location Icon States \u00b6 Possible icon states for the current location of a device on the map History Location Icon States \u00b6 Possible icon states for a historical point of a device on the map Map Examples \u00b6 Example of icons used in map context Metadata Example \u00b6 Icon State Fields Field Definition src The URL of the icon height Height of the icon (px) width Width of the icon (px) { \"icons\" : { \"mapbox\" : { \"history\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history.png\" , \"width\" : 48 }, \"history-rollover\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history-rollover.png\" , \"width\" : 48 }, \"history-selected\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history-selected.png\" , \"width\" : 48 }, \"normal\" : { \"height\" : 53 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-normal.png\" , \"width\" : 53 }, \"rollover\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-rollover.png\" , \"width\" : 80 }, \"rollover-selected\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-rollover-selected.png\" , \"width\" : 80 }, \"selected\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-selected.png\" , \"width\" : 80 } } Property Image Naming Convention normal blueprint-normal.png rollover blueprint-rollover.png selected blueprint-selected.png rollover-selected blueprint-rollover-selected.png history Global Icon: history.png, Blueprint-Specific Icon: blueprint-history.png history-rollover Global Icon: history-rollover.png, Blueprint-Specific Icon: blueprint-history-rollover.png history-selected Global Icon: history-selected.png, Blueprint-Specific Icon: blueprint-history-selected.png Navigation Icons \u00b6 The navIcon property is used in the top navigation bar and the sidebar, as well as the mobile navigation menu. You can set the default icon in the blueprint metadata. Format: SVG or PNG Icon usage in navigation Metadata Example \u00b6 { \"icons\" : { \"navIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-nav.svg\" } } Property Image Naming Convention navIcon blueprint-nav.svg Title Icons \u00b6 The screenIcon property is used in the header section of a given page. You can set the default icon in the blueprint metadata. Format: SVG or PNG Icon usage in screen titles Metadata Example \u00b6 { \"icons\" : { \"screenIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-title.svg\" } } Property Image Naming Convention screenIcon blueprint-title.svg Type Icons \u00b6 The typeIcon property is used in list cards, selection cards, and more. You can set the default icon in the blueprint metadata. Format: SVG or PNG Metadata Example \u00b6 { \"icons\" : { \"typeIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-normal.png\" } } For screen icons, some people prefer to use the same icon they used for the normal map property. If so, you will use the same file with the naming convention blueprint-normal.png. If you want to use a seperate file, follow the naming convention below. Property Image Naming Convention typeIcon blueprint-type.svg","title":"Icons"},{"location":"setup/branding/icons/#icon-configuration","text":"There are many situations where you will want to customize your icons, whether they are for your navigation, map, headers, or lists. This is easily accomplished by adding metadata via Architect. Before following along, please ensure you have access to our Architect UI. Edit blueprint metadata in the info tab Storing Icons Prior to any of this configuration, the icons must be uploaded to the cloud and hosted publically. We suggest using GCP for this step. You also must know the URL of each icon state.","title":"Icon Configuration"},{"location":"setup/branding/icons/#map-icons","text":"The metadata for map icons are found under the mapbox property, which is further subdivided by the icon state. Supported icon types for the map include your default icons (normal, rollover, selected, rollover-selected) and your historical point icons (history, history-rollover, history-selected). Format: PNG","title":"Map Icons"},{"location":"setup/branding/icons/#current-location-icon-states","text":"Possible icon states for the current location of a device on the map","title":"Current Location Icon States"},{"location":"setup/branding/icons/#history-location-icon-states","text":"Possible icon states for a historical point of a device on the map","title":"History Location Icon States"},{"location":"setup/branding/icons/#map-examples","text":"Example of icons used in map context","title":"Map Examples"},{"location":"setup/branding/icons/#metadata-example","text":"Icon State Fields Field Definition src The URL of the icon height Height of the icon (px) width Width of the icon (px) { \"icons\" : { \"mapbox\" : { \"history\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history.png\" , \"width\" : 48 }, \"history-rollover\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history-rollover.png\" , \"width\" : 48 }, \"history-selected\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history-selected.png\" , \"width\" : 48 }, \"normal\" : { \"height\" : 53 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-normal.png\" , \"width\" : 53 }, \"rollover\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-rollover.png\" , \"width\" : 80 }, \"rollover-selected\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-rollover-selected.png\" , \"width\" : 80 }, \"selected\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-selected.png\" , \"width\" : 80 } } Property Image Naming Convention normal blueprint-normal.png rollover blueprint-rollover.png selected blueprint-selected.png rollover-selected blueprint-rollover-selected.png history Global Icon: history.png, Blueprint-Specific Icon: blueprint-history.png history-rollover Global Icon: history-rollover.png, Blueprint-Specific Icon: blueprint-history-rollover.png history-selected Global Icon: history-selected.png, Blueprint-Specific Icon: blueprint-history-selected.png","title":"Metadata Example"},{"location":"setup/branding/icons/#navigation-icons","text":"The navIcon property is used in the top navigation bar and the sidebar, as well as the mobile navigation menu. You can set the default icon in the blueprint metadata. Format: SVG or PNG Icon usage in navigation","title":"Navigation Icons"},{"location":"setup/branding/icons/#metadata-example_1","text":"{ \"icons\" : { \"navIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-nav.svg\" } } Property Image Naming Convention navIcon blueprint-nav.svg","title":"Metadata Example"},{"location":"setup/branding/icons/#title-icons","text":"The screenIcon property is used in the header section of a given page. You can set the default icon in the blueprint metadata. Format: SVG or PNG Icon usage in screen titles","title":"Title Icons"},{"location":"setup/branding/icons/#metadata-example_2","text":"{ \"icons\" : { \"screenIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-title.svg\" } } Property Image Naming Convention screenIcon blueprint-title.svg","title":"Metadata Example"},{"location":"setup/branding/icons/#type-icons","text":"The typeIcon property is used in list cards, selection cards, and more. You can set the default icon in the blueprint metadata. Format: SVG or PNG","title":"Type Icons"},{"location":"setup/branding/icons/#metadata-example_3","text":"{ \"icons\" : { \"typeIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-normal.png\" } } For screen icons, some people prefer to use the same icon they used for the normal map property. If so, you will use the same file with the naming convention blueprint-normal.png. If you want to use a seperate file, follow the naming convention below. Property Image Naming Convention typeIcon blueprint-type.svg","title":"Metadata Example"},{"location":"setup/branding/inspector/","text":"UI Inspector Overview \u00b6 Enabling the Inspector The UI Inspector should only be enabled in your development environment. Engineers can enable the inspector per UI. Once the inspector is enabled, you can toggle it on and off using the keyboard shortcut Ctrl + i The UI Inspector allows designers to hover over any UI element in the interface and quickly see the element type and variant name. Because every element is nested in another, the inspector will show the child, then each consecutive parent in the panel. If the element in question is a pane, the inspector will include the layout as well. Inspector","title":"UI Inspector"},{"location":"setup/branding/inspector/#ui-inspector-overview","text":"Enabling the Inspector The UI Inspector should only be enabled in your development environment. Engineers can enable the inspector per UI. Once the inspector is enabled, you can toggle it on and off using the keyboard shortcut Ctrl + i The UI Inspector allows designers to hover over any UI element in the interface and quickly see the element type and variant name. Because every element is nested in another, the inspector will show the child, then each consecutive parent in the panel. If the element in question is a pane, the inspector will include the layout as well. Inspector","title":"UI Inspector Overview"},{"location":"setup/branding/logos/","text":"Updating Logos & Images \u00b6 The logos used in the interfaces are stored in the UI builder in various places. Below, we will show you where each logo is located so that you can update them anytime. Logo Storage The UI Builder does not store any files. Before you begin, please host your logos publicly on the web. We suggest using GCP for this step. Top Navigation Logo \u00b6 Top Navigation Logo Element Type: Button Variant Name: navLogo Mobile Override: mobileNavLogo SVG Format for Best Resolution Once you have located the variant, select the variant and navigate to the right hand panel. There, you will select the property tab and paste your URL. Paste URL into icon property field Login Page Options \u00b6 Login Page There are two branding assets that can be configured on this page. Company logo Background image (behind the white box) Login Logo \u00b6 The login logo is a different element & variant in the UI builder than the navLogo. The variant information is below. Element Type: Text Variant Name: loginLogo Edit the logo by navigating to the property tab and pasting the URL (same process as above) Login Background \u00b6 The login background is a pane and the image will be added as the URL of the background property. Element Type: Pane Variant Name: loginBackground Paste URL into background image field","title":"Logos"},{"location":"setup/branding/logos/#updating-logos-images","text":"The logos used in the interfaces are stored in the UI builder in various places. Below, we will show you where each logo is located so that you can update them anytime. Logo Storage The UI Builder does not store any files. Before you begin, please host your logos publicly on the web. We suggest using GCP for this step.","title":"Updating Logos &amp; Images"},{"location":"setup/branding/logos/#top-navigation-logo","text":"Top Navigation Logo Element Type: Button Variant Name: navLogo Mobile Override: mobileNavLogo SVG Format for Best Resolution Once you have located the variant, select the variant and navigate to the right hand panel. There, you will select the property tab and paste your URL. Paste URL into icon property field","title":"Top Navigation Logo"},{"location":"setup/branding/logos/#login-page-options","text":"Login Page There are two branding assets that can be configured on this page. Company logo Background image (behind the white box)","title":"Login Page Options"},{"location":"setup/branding/logos/#login-logo","text":"The login logo is a different element & variant in the UI builder than the navLogo. The variant information is below. Element Type: Text Variant Name: loginLogo Edit the logo by navigating to the property tab and pasting the URL (same process as above)","title":"Login Logo"},{"location":"setup/branding/logos/#login-background","text":"The login background is a pane and the image will be added as the URL of the background property. Element Type: Pane Variant Name: loginBackground Paste URL into background image field","title":"Login Background"},{"location":"setup/branding/notifications/","text":"Email & SMS Templates \u00b6 We provide three email templates out of the box in Architect. Any email template can be customized using our html editor. Below, we'll walk through how you can easily create and customize your emails. Adding a Template Our available templates are all easy to add under the New Template button in the top right corner Templates in Architect Available Templates \u00b6 Name Alias Purpose Invitation activateAccount When a user is invited to the system, they will receive this email invitation Reset Password resetPassword When a user selects forgot password via the login screen, they will receive this email Reset Password Successful resetPasswordSuccess After a user resets their password, they will receive a confirmation email Profile Changed profileChanged If a user changes any of their profile information, they will receive a confirmation email Login Code loginCode If a user requests a one-time access code via email, they will receive this email with the requested code Two-Step Verification twoFactorCode If a user enables two-step verification with their email, when they try to sign in they will receive this email as the second step in the process Login Code Error loginCodeError Users can not request one-time access codes with the same email that has two-step verification enabled. If they try to request a code, they will receive this email Editing Your Template \u00b6 When you select a template, you will see three tabs. Make sure you save any changes you make in the top right corner. Do not change the alias of a template Tabs Overview Info: Contains the name of the template and the alias . Editing the alias will break the template. Email: Most of the offered templates are email-only. Under the email tab, you will see a handlebar editor where you can edit the email and an email subject text field. Text: If the template has a supported SMS component, you will see the text message under the text tab. Email template editor Supported SMS Templates \u00b6 The following templates also support SMS versions. Name Alias Purpose Login Code loginCode If a user requests a one-time access code via text, they will receive this text with the requested code Two-Step Verification twoFactorCode If a user enables two-step verification with their phone number, when they try to sign in they will receive this text message as the second step in the process Login Code Error loginCodeError Users can not request one-time access codes with the same phone number that has two-step verification enabled. If they try to request a code, they will receive this text Configuring Your Template's Buttons \u00b6 Some email templates include a button that takes you to a given UI. Once you have your UI stood up on the desired URL, you can edit the URL information in a given button to ensure it takes you to the right place. < span style = \"background:#194edc; color:white; padding:10px 20px; border-radius:5px; font-size: 13px;\" > < a style = \"color:white;text-decoration:none;\" href = \"https://yourURLhere/activateAccount?username={{username}}&email={{email}}&token={{activationToken}}{{#if projectId}}&projectId={{projectId}}{{/if}}\" > Join Now </ a > </ span >","title":"Email & SMS Templates"},{"location":"setup/branding/notifications/#email-sms-templates","text":"We provide three email templates out of the box in Architect. Any email template can be customized using our html editor. Below, we'll walk through how you can easily create and customize your emails. Adding a Template Our available templates are all easy to add under the New Template button in the top right corner Templates in Architect","title":"Email &amp; SMS Templates"},{"location":"setup/branding/notifications/#available-templates","text":"Name Alias Purpose Invitation activateAccount When a user is invited to the system, they will receive this email invitation Reset Password resetPassword When a user selects forgot password via the login screen, they will receive this email Reset Password Successful resetPasswordSuccess After a user resets their password, they will receive a confirmation email Profile Changed profileChanged If a user changes any of their profile information, they will receive a confirmation email Login Code loginCode If a user requests a one-time access code via email, they will receive this email with the requested code Two-Step Verification twoFactorCode If a user enables two-step verification with their email, when they try to sign in they will receive this email as the second step in the process Login Code Error loginCodeError Users can not request one-time access codes with the same email that has two-step verification enabled. If they try to request a code, they will receive this email","title":"Available Templates"},{"location":"setup/branding/notifications/#editing-your-template","text":"When you select a template, you will see three tabs. Make sure you save any changes you make in the top right corner. Do not change the alias of a template Tabs Overview Info: Contains the name of the template and the alias . Editing the alias will break the template. Email: Most of the offered templates are email-only. Under the email tab, you will see a handlebar editor where you can edit the email and an email subject text field. Text: If the template has a supported SMS component, you will see the text message under the text tab. Email template editor","title":"Editing Your Template"},{"location":"setup/branding/notifications/#supported-sms-templates","text":"The following templates also support SMS versions. Name Alias Purpose Login Code loginCode If a user requests a one-time access code via text, they will receive this text with the requested code Two-Step Verification twoFactorCode If a user enables two-step verification with their phone number, when they try to sign in they will receive this text message as the second step in the process Login Code Error loginCodeError Users can not request one-time access codes with the same phone number that has two-step verification enabled. If they try to request a code, they will receive this text","title":"Supported SMS Templates"},{"location":"setup/branding/notifications/#configuring-your-templates-buttons","text":"Some email templates include a button that takes you to a given UI. Once you have your UI stood up on the desired URL, you can edit the URL information in a given button to ensure it takes you to the right place. < span style = \"background:#194edc; color:white; padding:10px 20px; border-radius:5px; font-size: 13px;\" > < a style = \"color:white;text-decoration:none;\" href = \"https://yourURLhere/activateAccount?username={{username}}&email={{email}}&token={{activationToken}}{{#if projectId}}&projectId={{projectId}}{{/if}}\" > Join Now </ a > </ span >","title":"Configuring Your Template's Buttons"},{"location":"setup/models/","text":"Models \u00b6 Molten uses the concept of a Model in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON. Characteristics \u00b6 A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them. Plain JSON Object \u00b6 Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism. Immutable \u00b6 Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences. Typed \u00b6 Models should have a type field that defines its unique identity. Normally this is a namespaced string such as myProject.MyModel Working with Models \u00b6 There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the @leverege/model-util library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: import MyModel from './MyModel' // If model was defined as model = { type : 'myMode' , value : 5 , subValues : { sv : 1 } } // WRONG - Dont do this model . value = 42 // CORRECT - Do this const nModel = MyModel . setValue ( model , 42 ) model === nModel // => false model . subValues === nModel . subValues // => true The @leverege/model-util will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking Plugins.add( 'Model', MyModel ) . Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type. If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network.","title":"Models"},{"location":"setup/models/#models","text":"Molten uses the concept of a Model in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON.","title":"Models"},{"location":"setup/models/#characteristics","text":"A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them.","title":"Characteristics"},{"location":"setup/models/#plain-json-object","text":"Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism.","title":"Plain JSON Object"},{"location":"setup/models/#immutable","text":"Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences.","title":"Immutable"},{"location":"setup/models/#typed","text":"Models should have a type field that defines its unique identity. Normally this is a namespaced string such as myProject.MyModel","title":"Typed"},{"location":"setup/models/#working-with-models","text":"There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the @leverege/model-util library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: import MyModel from './MyModel' // If model was defined as model = { type : 'myMode' , value : 5 , subValues : { sv : 1 } } // WRONG - Dont do this model . value = 42 // CORRECT - Do this const nModel = MyModel . setValue ( model , 42 ) model === nModel // => false model . subValues === nModel . subValues // => true The @leverege/model-util will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking Plugins.add( 'Model', MyModel ) . Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type. If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network.","title":"Working with Models"},{"location":"setup/models/editors/","text":"Model Editors \u00b6 ModelEditorFactory useValueChange Hook - Model and eventData Recursive ModelEditors in ModelEditors","title":"Model Editors"},{"location":"setup/models/editors/#model-editors","text":"ModelEditorFactory useValueChange Hook - Model and eventData Recursive ModelEditors in ModelEditors","title":"Model Editors"},{"location":"setup/models/model-util/","text":"Model Util \u00b6 Example createAllValue createAllArray discussion about normalization of this into { get, indexOf, removeAt, etc } createAllMap discussion about normalization of this into { get, indexOf, removeAt, etc }","title":"Model Util"},{"location":"setup/models/model-util/#model-util","text":"Example createAllValue createAllArray discussion about normalization of this into { get, indexOf, removeAt, etc } createAllMap discussion about normalization of this into { get, indexOf, removeAt, etc }","title":"Model Util"},{"location":"setup/nav/","text":"Plugins \u00b6 Molten makes heavy use of the @leverege/plugins library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few. Use \u00b6 The use of this library can be very simple and the requirements are very few: Including the library in your own code Defining an interface for your custom plugin mechanism (sometimes called Plugin Points) Picking a unique plugin name for your mechanism (usually namespaced, like . ) import { Plugins } from '@leverege/plugin' // 1 const plgs = Plugins . get ( 'myProject.Initializer' ) // 2 plgs . forEach ( ( initializer ) => { initializer . init () // 3 } ) In this example, we have defined our own custom plugin point that will invoke an init method at the appropriate time. It has imported the library (1), asked for all plugins registered as a myProject.Initializer plugin (2), and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. To participate in that example plugin point, simply add a plugin to the Plugin mechanism: import { Plugins } from '@leverege/plugin' // 1 MyInitializer = { init : () => { /* do something */ } } // Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer ) Plugins . add ( 'myProject.Initializer' , MyInitializer ) This Plugins.add() or molten.addPlugin() registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. Some plugin points are a little more complicated. These plugin points will often use match objects , type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values (like Molten's initializer plugins ) to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views . These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point. Observable \u00b6 The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. // Add a listener to all types const unsubscribeGlobal = Plugins . on ( listener ) // Add a listener to a specific type const unsubscribeType = Plugins . on ( 'myProject.Initializer' , listener ) // To remove a listener from all types Plugins . off ( listener ) // or use the returned function unsubscribeGlobal () // To remove a listener from a specific type Plugins . off ( 'myProject.Initializer' , listener ) // or use the returned function unsubscribeType () The listener method will be invoked with an object when an add or remove occurs: { type , // either 'pluginAdded' or 'pluginRemoved', pluginType , // The plugin type that changed plugin , // The plugin that was added or removed plugins // The Plugins object } An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. const version = Plugins . getVersion ( 'myProject.Initializer' ) Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set. const version = Plugins . getVersion ( 'myProject.PluginPoint' ) // React Example const result = useMemo ( ( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, [ version ] ) // @leverege/value-cache example const result = valueCache . calc (( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, version )","title":"Plugins"},{"location":"setup/nav/#plugins","text":"Molten makes heavy use of the @leverege/plugins library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few.","title":"Plugins"},{"location":"setup/nav/#use","text":"The use of this library can be very simple and the requirements are very few: Including the library in your own code Defining an interface for your custom plugin mechanism (sometimes called Plugin Points) Picking a unique plugin name for your mechanism (usually namespaced, like . ) import { Plugins } from '@leverege/plugin' // 1 const plgs = Plugins . get ( 'myProject.Initializer' ) // 2 plgs . forEach ( ( initializer ) => { initializer . init () // 3 } ) In this example, we have defined our own custom plugin point that will invoke an init method at the appropriate time. It has imported the library (1), asked for all plugins registered as a myProject.Initializer plugin (2), and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. To participate in that example plugin point, simply add a plugin to the Plugin mechanism: import { Plugins } from '@leverege/plugin' // 1 MyInitializer = { init : () => { /* do something */ } } // Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer ) Plugins . add ( 'myProject.Initializer' , MyInitializer ) This Plugins.add() or molten.addPlugin() registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. Some plugin points are a little more complicated. These plugin points will often use match objects , type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values (like Molten's initializer plugins ) to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views . These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point.","title":"Use"},{"location":"setup/nav/#observable","text":"The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. // Add a listener to all types const unsubscribeGlobal = Plugins . on ( listener ) // Add a listener to a specific type const unsubscribeType = Plugins . on ( 'myProject.Initializer' , listener ) // To remove a listener from all types Plugins . off ( listener ) // or use the returned function unsubscribeGlobal () // To remove a listener from a specific type Plugins . off ( 'myProject.Initializer' , listener ) // or use the returned function unsubscribeType () The listener method will be invoked with an object when an add or remove occurs: { type , // either 'pluginAdded' or 'pluginRemoved', pluginType , // The plugin type that changed plugin , // The plugin that was added or removed plugins // The Plugins object } An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. const version = Plugins . getVersion ( 'myProject.Initializer' ) Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set. const version = Plugins . getVersion ( 'myProject.PluginPoint' ) // React Example const result = useMemo ( ( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, [ version ] ) // @leverege/value-cache example const result = valueCache . calc (( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, version )","title":"Observable"},{"location":"setup/nav/page/","text":"Screen Display Options \u00b6 Nesting Screen Display \u00b6 So far, we have used the automatic screen display option, which we call the nesting display. For the nesting display, when you select an item, you are drilled into an entirely new page about that item, featuring a sidebar of that item's children (example below). Nesting Screen Display Embedded Screen Display \u00b6 In many cases, you don't want the entire page to change when you click on an item. Instead, you want the details of a specific item to replace the item list. For example, if you are looking at a list of assets in your location and you select one to learn more, you might not want the side navigation to change to display that asset and it's children. Embedded Screen Display In the image above, you can see the asset details screen replaced the list screen without changing the side navigation. On top of that, in the event that the asset is the parent in a relationship, you will see those child blueprint pages in the top section of the asset detail view. The tag to embed a screen is itemScreen:embed . This is a tag added to the relationship attribute of the blueprint you want to embed. No Screen Display \u00b6 Sometimes, you don't want your user to drill into an item at all. The tag to hide the drill down page all together is itemScreen:none .","title":"Page Display Options"},{"location":"setup/nav/page/#screen-display-options","text":"","title":"Screen Display Options"},{"location":"setup/nav/page/#nesting-screen-display","text":"So far, we have used the automatic screen display option, which we call the nesting display. For the nesting display, when you select an item, you are drilled into an entirely new page about that item, featuring a sidebar of that item's children (example below). Nesting Screen Display","title":"Nesting Screen Display"},{"location":"setup/nav/page/#embedded-screen-display","text":"In many cases, you don't want the entire page to change when you click on an item. Instead, you want the details of a specific item to replace the item list. For example, if you are looking at a list of assets in your location and you select one to learn more, you might not want the side navigation to change to display that asset and it's children. Embedded Screen Display In the image above, you can see the asset details screen replaced the list screen without changing the side navigation. On top of that, in the event that the asset is the parent in a relationship, you will see those child blueprint pages in the top section of the asset detail view. The tag to embed a screen is itemScreen:embed . This is a tag added to the relationship attribute of the blueprint you want to embed.","title":"Embedded Screen Display"},{"location":"setup/nav/page/#no-screen-display","text":"Sometimes, you don't want your user to drill into an item at all. The tag to hide the drill down page all together is itemScreen:none .","title":"No Screen Display"},{"location":"setup/nav/path-overrides/","text":"Styling Overrides \u00b6 To override any blueprint metadata at a specific relationship path, add the property to the metadata of the relationship attribute. For example, to override the location navicon at the company level, you\u2019ll go to the company blueprint\u2019s location attribute and add the metadata. You can override anything from icons & strings to illustrations and documentation links. Anything you have been able to configure thus far can be changed.","title":"Styling Overrides"},{"location":"setup/nav/path-overrides/#styling-overrides","text":"To override any blueprint metadata at a specific relationship path, add the property to the metadata of the relationship attribute. For example, to override the location navicon at the company level, you\u2019ll go to the company blueprint\u2019s location attribute and add the metadata. You can override anything from icons & strings to illustrations and documentation links. Anything you have been able to configure thus far can be changed.","title":"Styling Overrides"},{"location":"setup/nav/role/","text":"Role-Specific Setup \u00b6 If you want a role to have a specific home page in the UI, you can add metadata to the role to specify it's home page. To add the metadata, head to the roles tab in Architect and select the role. In the right panel, you will see an edit button next to the metadata section. Editing Metadata in Architect Properties \u00b6 JSON Path Definition ui/defaultUrl Stores metadata for an initial url calculator for this role. ui/excludeFrom Used to filter roles from being presented in the UI. This includes the role picker in the user menu (top right of UI) and all model editors where a role can be selected for saving/loading models. ui/blockFrom Used to prevent users with certain roles from logging into named or default UIs priority Used by the UI to determine which role should take precedence when a user is assigned to multiple roles. usedAtBlueprints Used to filter roles presented in the User Access screen for a given object type. { \"ui\" : { \"defaultUrl\" : { \"type\" : \"urlPathRoleCalculator\" , \"single\" : \"/p/roleName/blueprintAlias/:resourceId\" , \"multiple\" : \"/p/roleName/blueprintAlias\" , \"resourceType\" : \"blueprintUUID\" }, \"blockFrom\" : [ \"uiName\" ], \"excludeFrom\" : [ \"uiName\" ] }, \"priority\" : 1 , \"usedAtBlueprints\" : [ \"blueprintAlias\" ] }","title":"Role-Specific Settings"},{"location":"setup/nav/role/#role-specific-setup","text":"If you want a role to have a specific home page in the UI, you can add metadata to the role to specify it's home page. To add the metadata, head to the roles tab in Architect and select the role. In the right panel, you will see an edit button next to the metadata section. Editing Metadata in Architect","title":"Role-Specific Setup"},{"location":"setup/nav/role/#properties","text":"JSON Path Definition ui/defaultUrl Stores metadata for an initial url calculator for this role. ui/excludeFrom Used to filter roles from being presented in the UI. This includes the role picker in the user menu (top right of UI) and all model editors where a role can be selected for saving/loading models. ui/blockFrom Used to prevent users with certain roles from logging into named or default UIs priority Used by the UI to determine which role should take precedence when a user is assigned to multiple roles. usedAtBlueprints Used to filter roles presented in the User Access screen for a given object type. { \"ui\" : { \"defaultUrl\" : { \"type\" : \"urlPathRoleCalculator\" , \"single\" : \"/p/roleName/blueprintAlias/:resourceId\" , \"multiple\" : \"/p/roleName/blueprintAlias\" , \"resourceType\" : \"blueprintUUID\" }, \"blockFrom\" : [ \"uiName\" ], \"excludeFrom\" : [ \"uiName\" ] }, \"priority\" : 1 , \"usedAtBlueprints\" : [ \"blueprintAlias\" ] }","title":"Properties"},{"location":"setup/nav/route/","text":"Roots \u00b6 In your UI, you have the ability to decide which blueprint or blueprints will be your root(s). By making a blueprint a root, you are selecting that blueprint to be the root of your hierarchy for that section of the UI. The root page will load a system-wide list of every item of that blueprint type. Let's take the hierarchy below as our example. Hierarchy diagram Let's break down the relationships in the example above. The company blueprint has 3 child relationships, all of which are one-to-many. The child blueprints are: Location Blueprint Asset Blueprint Tracker Blueprint The location blueprint also has child relationships, all of which are one-to-many. These child blueprints are: Asset Blueprint Tracker Blueprint Zone Blueprint Beacon Blueprint Floor Blueprint For a refresher on relationship types and usages, { please refer to this link. } Selecting Roots \u00b6 You can have one root or multiple roots in your UI. In this case, it makes sense for the company blueprint to be a root, which will make the company blueprint a top level navigation option. Company root example On top of adding companies to the top level navigation, the root also will only load that blueprint and it's children. For example, if you selected the location blueprint as a root along with the company blueprint, you would see both in the top nav (example below). Multi-root example Under the location's tab, you will have entirely new set of pages, representing the child blueprints, in your UI. This pages will be completely separate from the pages representing the same blueprint under the company root. To help visual this, take a look at the diagram below. Multi-root hierarchy Root Groups \u00b6 In some cases, it's helpful to see your assets or trackers across all companies or locations at the root level. In these types of cases, we find it helpful to group those pages together. The grouping mechanism puts a group of root pages into a dropdown in the top navigation, saving you critical screen space. Group dropdown example These pages will load individually, so you will have one page for a system-wide list of assets and one for a system-wide list of trackers. Configuring Roots \u00b6 To make a blueprint a root, all you have to do is add the tag is:root to the blueprint tag section. Group dropdown example Below are the different types of configuration options for roots via tags. Property Purpose is:root Adds the blueprint to the top-level navigation as a root rootNavGroup:<Name> If a blueprint is set as a root, it can be added to a group in the top navigation. Name represents which group the blueprint is added to and is used in the label of the dropdown rootNavGroupIcons:<URL> To set the icon for a group, use this tag on any blueprint in that group. This icon must be hosted publicly online Hiding Roots from Specific Roles \u00b6 Not every role should have the same access, and the same goes for roots. You can easily hide a root from a given role by using the tag excludeFrom:<Role> Property Purpose excludeFrom:<Role> Hides this root from a given role excludeFrom:* Hides this root from all roles. Useful when more than one UI is used for a given project and a root is only needed for one of the two UIs. Note that this requires mutations to implement.","title":"Roots"},{"location":"setup/nav/route/#roots","text":"In your UI, you have the ability to decide which blueprint or blueprints will be your root(s). By making a blueprint a root, you are selecting that blueprint to be the root of your hierarchy for that section of the UI. The root page will load a system-wide list of every item of that blueprint type. Let's take the hierarchy below as our example. Hierarchy diagram Let's break down the relationships in the example above. The company blueprint has 3 child relationships, all of which are one-to-many. The child blueprints are: Location Blueprint Asset Blueprint Tracker Blueprint The location blueprint also has child relationships, all of which are one-to-many. These child blueprints are: Asset Blueprint Tracker Blueprint Zone Blueprint Beacon Blueprint Floor Blueprint For a refresher on relationship types and usages, { please refer to this link. }","title":"Roots"},{"location":"setup/nav/route/#selecting-roots","text":"You can have one root or multiple roots in your UI. In this case, it makes sense for the company blueprint to be a root, which will make the company blueprint a top level navigation option. Company root example On top of adding companies to the top level navigation, the root also will only load that blueprint and it's children. For example, if you selected the location blueprint as a root along with the company blueprint, you would see both in the top nav (example below). Multi-root example Under the location's tab, you will have entirely new set of pages, representing the child blueprints, in your UI. This pages will be completely separate from the pages representing the same blueprint under the company root. To help visual this, take a look at the diagram below. Multi-root hierarchy","title":"Selecting Roots"},{"location":"setup/nav/route/#root-groups","text":"In some cases, it's helpful to see your assets or trackers across all companies or locations at the root level. In these types of cases, we find it helpful to group those pages together. The grouping mechanism puts a group of root pages into a dropdown in the top navigation, saving you critical screen space. Group dropdown example These pages will load individually, so you will have one page for a system-wide list of assets and one for a system-wide list of trackers.","title":"Root Groups"},{"location":"setup/nav/route/#configuring-roots","text":"To make a blueprint a root, all you have to do is add the tag is:root to the blueprint tag section. Group dropdown example Below are the different types of configuration options for roots via tags. Property Purpose is:root Adds the blueprint to the top-level navigation as a root rootNavGroup:<Name> If a blueprint is set as a root, it can be added to a group in the top navigation. Name represents which group the blueprint is added to and is used in the label of the dropdown rootNavGroupIcons:<URL> To set the icon for a group, use this tag on any blueprint in that group. This icon must be hosted publicly online","title":"Configuring Roots"},{"location":"setup/nav/route/#hiding-roots-from-specific-roles","text":"Not every role should have the same access, and the same goes for roots. You can easily hide a root from a given role by using the tag excludeFrom:<Role> Property Purpose excludeFrom:<Role> Hides this root from a given role excludeFrom:* Hides this root from all roles. Useful when more than one UI is used for a given project and a root is only needed for one of the two UIs. Note that this requires mutations to implement.","title":"Hiding Roots from Specific Roles"},{"location":"setup/nav/sort/","text":"Sort & Order Pages \u00b6 Once you have selected and set up your root, you will find that by clicking on a root item, you are taken to a new page in the UI with a sidebar navigation. For example, let\u2019s look at our example with locations. Location example The sidebar navigation includes: An overview page of the item, named Overview All blueprints that have the location blueprint as a parent, regardless of if the relationship is one-to-one or one-to-many If user management is enabled, a users page. For more information on enabling user management, review {==our documentation here. ==} !!! Tip \u201cIcons\u201d Reminder that the icons loading into the side navigation were set in the blueprint metadata. Revisit our icons documentation to review this process. Sections & Ordering \u00b6 Desired Layout We are going to break down how you get from the left sidebar navigation above to the right sidebar. To start, let\u2019s break out and order our sections. The tag to order your blueprints is navSort:<SORT_KEY> , where the sort key is comprised of a letter that determines the section and a number that determines the order. The letter and number are separated by a period. Each blueprint's tag is outlined below. Assets: navSort:a.1 Trackers: navSort:a.2 Beacons: navSort:b.1 Floors: navSort:b.2 Zones: navSort:b.3 Because you are sorting the children relationships of a location, these tags get added to the relationship attribute of each blueprint on the location blueprint (image below). Once the tags are applied, you will see a divider align appear between section a & b. Relationship attribute editor The overview and users pages are ordered with different tags. These tags are added to the location blueprint itself. Tag Purpose navSortOverview:<SORT_KEY> To order the overview page, add this tag to the parent blueprint navSortUserManagement:<SORT_KEY> To order the users page, add this tag to the parent blueprint For our example we're working on, the overview and users tags would follow the example below. Overview: navSortOverview:c.1 Users: navSortUserManagement:c.2 Now that we've added all of our tags, our sidebar should look like the sidebar on the left in the image below. We'll be reviewing how to add section titles next. Sections & Ordering Outcome/figcaption> Section Names \u00b6 To add a section name, you'll want to identify the first page in each section. For our inventory section, the first page is the assets attribute. This is where you will add the tag navSectionName:<NAME> . If you want to add the section name above the user management or overview pages, you will need to add a string to your metadata on the parent blueprint. In this case, we would add the string to the metadata on the location blueprint. String Purpose overviewSectionName If the overview page is the first page in a section, add this string to the parent blueprint metadata with the desired name. userManagementSectionName If the users page is the first page in a section, add this string to the parent blueprint metadata with the desired name. For our example, we added the two tags below. On the assets attribute at the location blueprint: navSectionName:Inventory On the beacons attribute at the location blueprint: navSectionName:Installation To add the location management section name, we added the following metadata to the location blueprint. { \"strings\" : { \"overviewSectionName\" : \"Location Management\" } Hiding Pages from Roles \u00b6 Not every role permissioned to a location should have access to every page. To quickly and easily hide a page from a role, use the excludeFrom:<Role> tag on the relationship attribute if the page is a blueprint. The user management page will only appear if the user has permission to perform user management actions. The overview page will appear for any user permissioned to that blueprint.","title":"Sort & Order Pages"},{"location":"setup/nav/sort/#sort-order-pages","text":"Once you have selected and set up your root, you will find that by clicking on a root item, you are taken to a new page in the UI with a sidebar navigation. For example, let\u2019s look at our example with locations. Location example The sidebar navigation includes: An overview page of the item, named Overview All blueprints that have the location blueprint as a parent, regardless of if the relationship is one-to-one or one-to-many If user management is enabled, a users page. For more information on enabling user management, review {==our documentation here. ==} !!! Tip \u201cIcons\u201d Reminder that the icons loading into the side navigation were set in the blueprint metadata. Revisit our icons documentation to review this process.","title":"Sort &amp; Order Pages"},{"location":"setup/nav/sort/#sections-ordering","text":"Desired Layout We are going to break down how you get from the left sidebar navigation above to the right sidebar. To start, let\u2019s break out and order our sections. The tag to order your blueprints is navSort:<SORT_KEY> , where the sort key is comprised of a letter that determines the section and a number that determines the order. The letter and number are separated by a period. Each blueprint's tag is outlined below. Assets: navSort:a.1 Trackers: navSort:a.2 Beacons: navSort:b.1 Floors: navSort:b.2 Zones: navSort:b.3 Because you are sorting the children relationships of a location, these tags get added to the relationship attribute of each blueprint on the location blueprint (image below). Once the tags are applied, you will see a divider align appear between section a & b. Relationship attribute editor The overview and users pages are ordered with different tags. These tags are added to the location blueprint itself. Tag Purpose navSortOverview:<SORT_KEY> To order the overview page, add this tag to the parent blueprint navSortUserManagement:<SORT_KEY> To order the users page, add this tag to the parent blueprint For our example we're working on, the overview and users tags would follow the example below. Overview: navSortOverview:c.1 Users: navSortUserManagement:c.2 Now that we've added all of our tags, our sidebar should look like the sidebar on the left in the image below. We'll be reviewing how to add section titles next. Sections & Ordering Outcome/figcaption>","title":"Sections &amp; Ordering"},{"location":"setup/nav/sort/#section-names","text":"To add a section name, you'll want to identify the first page in each section. For our inventory section, the first page is the assets attribute. This is where you will add the tag navSectionName:<NAME> . If you want to add the section name above the user management or overview pages, you will need to add a string to your metadata on the parent blueprint. In this case, we would add the string to the metadata on the location blueprint. String Purpose overviewSectionName If the overview page is the first page in a section, add this string to the parent blueprint metadata with the desired name. userManagementSectionName If the users page is the first page in a section, add this string to the parent blueprint metadata with the desired name. For our example, we added the two tags below. On the assets attribute at the location blueprint: navSectionName:Inventory On the beacons attribute at the location blueprint: navSectionName:Installation To add the location management section name, we added the following metadata to the location blueprint. { \"strings\" : { \"overviewSectionName\" : \"Location Management\" }","title":"Section Names"},{"location":"setup/nav/sort/#hiding-pages-from-roles","text":"Not every role permissioned to a location should have access to every page. To quickly and easily hide a page from a role, use the excludeFrom:<Role> tag on the relationship attribute if the page is a blueprint. The user management page will only appear if the user has permission to perform user management actions. The overview page will appear for any user permissioned to that blueprint.","title":"Hiding Pages from Roles"}]}