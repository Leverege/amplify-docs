{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"architecture/","text":"Plugins \u00b6 These plugins are automatically installed with Molten.","title":"Plugins"},{"location":"architecture/#plugins","text":"These plugins are automatically installed with Molten.","title":"Plugins"},{"location":"config/","text":"This describes the values in the Molten Confg.js file. Show/Hide the Layout Controller Path plugins/config/LayoutViewerSelector Allows visibility control of the layout button in GroupScreen and ItemInfoScreen. { allowEditing : | } for example: { allowEditing : \"Installer, Admin\" } Would allow user in the persona of Installer or Admin to see the buttons plugins/config/mapBoxPosition Sets default position and zoom. selectedRezoomThreshold: Indicates at what range (or less ) the view should recenter/zoom in on the selected object. selectedZoom : target zoom when selection occurs and rezoom threshold is exceeded. ( Negative one means dont zoom ) pathOptions : an object where the keys are the blueprint paths to allow customization of selectedRezoom options. { center : [ -77.1902656, 39.1081595 ], zoom : 18, selectedRezoomThreshold : 12, // if we re beyond this range, selection will cause rezoom/center selectedZoom : 18, // this is the target range to go to on selection. pathOptions : { building : { selectedRezoomThreshold : 10, selectedZoom : 18 } } } UserManagement / ResourceUser Screen Under plugins/config/ResourceUsers, the following keys can be set to change properties: Key Default userSelectorUsernameLabel Email or Username* userSelectorUsernameHint Enter Email or Username userSelectorUsernameInstructions Enter user's email or username and hit enter or next to continue. addUserTitle Add User editUserTitle Edit User addUserOkay Next editUserUpdate Update allowCreateUser true allowInviteUser true inviteEmailLabel Email* inviteEmailHint Enter Email createEmailLabel Account Email* createEmailHint ex. johnsmith@example.com createUsernameLabel Username createUsernameHint Enter Username activateEmailLabel Account Email* createNameLabel Name* createNameHint ex. John Smith createPhoneLabel Phone Number createPhoneHint ex. (555) 555-5555 createPasswordLabel Password createPasswordHint Enter password createConfirmPasswordLabel Confirm Password createConfirmPasswordHint Re-enter password screenIcon addDialogIcon editDialogIcon removeUserDialogIcon 404 / LostScreen Under plugins/config/LostScreen, the following keys can be set to change properties: Key Default Description title Oops! The title to put on the page message We couldn't find this page - our apologies! The sub text to display to the user button Let's find our way The label of the button on the \u2018home\u2019 link link '/' The location to take the user when the button is pressed image fa fa-meh-o The font icon or image url to display. This can also be an array of font icons and image urls. If it is an Array, one will randomly be selected and used. These images are supplied as good initial resource.s LostScreen : { image : [ 'https://molten-ui-assets.storage.googleapis.com/404-UFO.png', 'https://molten-ui-assets.storage.googleapis.com/404-Earth.png', 'https://molten-ui-assets.storage.googleapis.com/404-Page.png', 'https://molten-ui-assets.storage.googleapis.com/404-Ghost.png' ] } NetworkOffline Under plugins/config/NetworkOffline, the following keys can be set to change properties: Key Default Description message Your Network connection has been lost. The message to display when network connection is lost. icon fa fa-exclamation-triangle The font icon class or image url to display with the text, when the connection is lost. BlueprintActions Under plugins/config/BlueprintActions, the following keys can be set to change properties: Key Default Description updateIcon fa fa-pencil fa-fw The font icon class or image url to display for a blueprint update action. createIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint create action. bulkCreateIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint bulk create action. removeIcon fa fa-trash fa-fw The font icon class or image url to display for a blueprint remove action. No Data/No Search Results Views Under plugins/config/ where is one of ListDataViewer or TableDataViewer the following keys can be set to change the no data/no search results views: Key Default Description noDataMessage The class found in molten at: src/screens/shared/group/noData/NoDataView.jsx The string or React Component/Function to render when there is no data in the table/list Under plugins/config/NoDataView the following keys can be set to configure the NoDataView that is used by default Key Default Description Key Default Description noDataTitle the name of the blueprint Can be overridden by a string in the blueprint or attribute noDataBody Looks like there's nothing here, try creating something! Can be overridden by a string in the blueprint or attribute noDataIcon https://molten-ui-assets.storage.googleapis.com/no-data.svg Can be overridden by a string in the blueprint or attribute noDataIconDimensions { height : 224, width : 224 } Can be overridden by a string in the blueprint or attribute noDataDocLink null Can be overridden by a string in the blueprint or attribute noSearchResultsTitle We couldn't find any matches for that Can be overridden by a string in the blueprint or attribute noSearchResultsBody Please try searching for another item Can be overridden by a string in the blueprint or attribute noSearchResultsIcon https://molten-ui-assets.storage.googleapis.com/no-search-results.svg Can be overridden by a string in the blueprint or attribute noSearchResultsIconDimensions { height : 224, width : 224 } Can be overridden by a string in the blueprint or attribute","title":"Index"},{"location":"features/","text":"","title":"Index"},{"location":"features/account/authentication/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Two-Step Verification"},{"location":"features/account/authentication/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/account/authentication/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/account/roles/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Multi-Role Management"},{"location":"features/account/roles/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/account/roles/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/account/signincode/","text":"Pets have 3 attributes (besides their id): Name, Age, and Position. To be able to view these attributes in a table, update form, or creation form, Attribute plugins must be created for them. Attributes plugins have a few required fields, namely: name - The name of the Attribute, which is used to look it up along with objectType to perform common operations objectType - The type of object this Attribute is relevant to, which is used along with name to look it up to perform common operations valueType - The type of the attribute, which can be anything, but common types include strings , numbers , integers , geoPoints , geoJson , and Timestamp . get - This function is used by display and update mechanisms to get the current value of this attribute given an instance of the objectType it pertains to and some context displayName - A field of the Attribute used to display the attribute in lists for configuration or default titles Name Attribute Age Attribute Position Attribute Setup { name : 'name' , objectType : 'petApi.pet' , valueType : 'string' , get : ( data , cxt ) => { return data ? . name }, displayName : 'Name' } { name : 'age' , objectType : 'petApi.pet' , valueType : 'number' , get : ( data , cxt ) => { return data ? . age }, displayName : 'Age' } { name : 'geoPosition' , objectType : 'petApi.pet' , valueType : 'geoPoint' , get : ( data , cxt ) => { return data ? . position }, displayName : 'Position' } molten . addPlugin ( 'Attribute' , NameAttribute ) molten . addPlugin ( 'Attribute' , AgeAttribute ) molten . addPlugin ( 'Attribute' , PositionAttribute )","title":"One-Time Access Code"},{"location":"features/create/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/create/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/create/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/fota/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/fota/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/fota/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/map/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/map/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/map/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/map/multifloor/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Multi-Floor Management"},{"location":"features/map/multifloor/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/map/multifloor/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/map/zone/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Zones"},{"location":"features/map/zone/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/map/zone/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/pair/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/pair/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/pair/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/search/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Index"},{"location":"features/search/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/search/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"features/search/quicksearch/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Quick Search"},{"location":"features/search/quicksearch/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"features/search/quicksearch/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"getting-started/","text":"Getting Started \u00b6 Doc index.md","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Doc index.md","title":"Getting Started"},{"location":"getting-started/i18n/","text":"Localization \u00b6 i18n.md Installing Bundler \u00b6 Checking for translations \u00b6","title":"Localization"},{"location":"getting-started/i18n/#localization","text":"i18n.md","title":"Localization"},{"location":"getting-started/i18n/#installing-bundler","text":"","title":"Installing Bundler"},{"location":"getting-started/i18n/#checking-for-translations","text":"","title":"Checking for translations"},{"location":"intro/","text":"API \u00b6 Api Referenece","title":"API"},{"location":"intro/#api","text":"Api Referenece","title":"API"},{"location":"setup/","text":"UI Setup Overview \u00b6 In this section, we will be covering how to update the Style & Brand of your UI Create & Sort the Navigation Additional Options Available via Development This Section is for Pre-Created Projects If you have not already created your blueprints, relationships, and roles, please review our data architecture section to get started","title":"UI Setup Overview"},{"location":"setup/#ui-setup-overview","text":"In this section, we will be covering how to update the Style & Brand of your UI Create & Sort the Navigation Additional Options Available via Development This Section is for Pre-Created Projects If you have not already created your blueprints, relationships, and roles, please review our data architecture section to get started","title":"UI Setup Overview"},{"location":"setup/dev/","text":"Developer Options \u00b6 Developers have more UI setup options available in the config file for the UI. You can review the complete guide to what developers can [configure here] (https://leverege-steve-molten-docs.web.app/config/). Some developer configuration options include: Configuration: Hiding configuration tools from end-users 404 Screen: Changing the copy & illustrations on the 404 screen Network Offline Alert: Changing the copy and icon of the network offline alert Blueprint Action Icons: Changing the create, bulk create, remove, and edit icons User Management: Change different labels & description text within the user management plugin (ie renaming username to account email)","title":"Overview"},{"location":"setup/dev/#developer-options","text":"Developers have more UI setup options available in the config file for the UI. You can review the complete guide to what developers can [configure here] (https://leverege-steve-molten-docs.web.app/config/). Some developer configuration options include: Configuration: Hiding configuration tools from end-users 404 Screen: Changing the copy & illustrations on the 404 screen Network Offline Alert: Changing the copy and icon of the network offline alert Blueprint Action Icons: Changing the create, bulk create, remove, and edit icons User Management: Change different labels & description text within the user management plugin (ie renaming username to account email)","title":"Developer Options"},{"location":"setup/attributes/","text":"Attributes \u00b6","title":"Attributes"},{"location":"setup/attributes/#attributes","text":"","title":"Attributes"},{"location":"setup/attributes/data-sources/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"setup/attributes/data-sources/#data-sources","text":"","title":"Data Sources"},{"location":"setup/attributes/details/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"setup/attributes/details/#data-sources","text":"","title":"Data Sources"},{"location":"setup/attributes/formatters/","text":"Formatters \u00b6","title":"Formatters"},{"location":"setup/attributes/formatters/#formatters","text":"","title":"Formatters"},{"location":"setup/attributes/graph/","text":"Graphing \u00b6","title":"Graphing"},{"location":"setup/attributes/graph/#graphing","text":"","title":"Graphing"},{"location":"setup/attributes/relationships/","text":"Relationships \u00b6","title":"Relationships"},{"location":"setup/attributes/relationships/#relationships","text":"","title":"Relationships"},{"location":"setup/attributes/table/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"setup/attributes/table/#data-sources","text":"","title":"Data Sources"},{"location":"setup/branding/","text":"Branding \u00b6 The Leverege Stack makes customizing the end-user interfaces and emails to your brand very simple. In this section, we'll cover how you can use the UI builder, our global theming engine, and our email/text templates to ensure that your product is visually stunning. UI Theme \u00b6 The UI Builder is a stand-alone tool that allows you to edit & update the CSS theme of all UI elements in real time on your development site. This empowers you to change everything from a button color to the flex direction of a pane, all in one place. UI Inspector \u00b6 In your interfaces, you can turn on the UI inspector, which tells you what variant in the UI builder you are looking at. This allows you to quickly identify and update a given style of a css variant of a UI element. Logos & Branding \u00b6 It's easy to swap in and out different logos in your UIs using the UI Builder. Read our detailed instructions in the logos section. Icons \u00b6 We provide ample opportunity to customize icons. Customize your map icons, navigation icons, title bar icons, and more. Email & SMS Templates \u00b6 You don't have to start from scratch with your notifications. We provide 7 email templates and 3 SMS templates out of the box and provide an easy handlebar editor so you can make any customization you'd like. Empty States & Illustrations \u00b6 When a user is just starting out, it's helpful to guide them through the experience with clear directions and help links. A little illustration here or there never hurt anyone either.","title":"Branding"},{"location":"setup/branding/#branding","text":"The Leverege Stack makes customizing the end-user interfaces and emails to your brand very simple. In this section, we'll cover how you can use the UI builder, our global theming engine, and our email/text templates to ensure that your product is visually stunning.","title":"Branding"},{"location":"setup/branding/#ui-theme","text":"The UI Builder is a stand-alone tool that allows you to edit & update the CSS theme of all UI elements in real time on your development site. This empowers you to change everything from a button color to the flex direction of a pane, all in one place.","title":"UI Theme"},{"location":"setup/branding/#ui-inspector","text":"In your interfaces, you can turn on the UI inspector, which tells you what variant in the UI builder you are looking at. This allows you to quickly identify and update a given style of a css variant of a UI element.","title":"UI Inspector"},{"location":"setup/branding/#logos-branding","text":"It's easy to swap in and out different logos in your UIs using the UI Builder. Read our detailed instructions in the logos section.","title":"Logos &amp; Branding"},{"location":"setup/branding/#icons","text":"We provide ample opportunity to customize icons. Customize your map icons, navigation icons, title bar icons, and more.","title":"Icons"},{"location":"setup/branding/#email-sms-templates","text":"You don't have to start from scratch with your notifications. We provide 7 email templates and 3 SMS templates out of the box and provide an easy handlebar editor so you can make any customization you'd like.","title":"Email &amp; SMS Templates"},{"location":"setup/branding/#empty-states-illustrations","text":"When a user is just starting out, it's helpful to guide them through the experience with clear directions and help links. A little illustration here or there never hurt anyone either.","title":"Empty States &amp; Illustrations"},{"location":"setup/branding/builder/","text":"UI Builder Overview \u00b6 The UI Builder is an application that empowers users with the ability to style UI elements and make visual changes to UI elements in-real time. UI Builder is aimed at designers and other non-technical users to be able to make UI style changes quickly. By making UI style changes through UI Builder, users do not need to know how to code, manipulate HTML/CSS, or redeploy a project. Designers can make styling changes independently of engineers building out the application. This reduces the need to ask engineers to make styling changes and shortens the communication loop. Active Themes Active themes should only be used on dev environments. In your staging and production environments, engineers will export the theme during the deployment so that it is \"static\". This ensures that designers do not accidentally turn an entire production interface pink, for example. Navigating the UI Builder \u00b6 Every project has it's own UI builder project associated with it. If a given project has multiple UIs, the same UI builder project or multiple UI builder projects can be used per UI. UI Builder projects are organized by the type of UI element you are editing. You can find the categories down the left side of the project. UI Builder Project When a user clicks into a specific UI element, they can visually see an example of the UI element and can manually update nearly every aspect of it (e.g. color, padding, borders, hover states etc.). Any changes they make to the element are live changes to the development UI. UI Builder Element Editor Variants \u00b6 Each UI type has variations of that element called variants. A variant is a way to reuse the style of a given element in multiple places. For example, if a designer wants to use the same style button on two different places in the UI, they would use the same variant and any changes made to that variant on UI Builder will update both of those buttons. This means that all the designer has to do is specify to the engineer that a given button should inherit a given variant. It also means the engineer can code/place the button and the designer can then use the UI builder to fine tune how it looks. For some components, the variant can be specified in configuration panel of the UI component itself rather than needing to communicate it to the engineer. Creating a New Variant \u00b6 Create a variant by clicking the type of UI element in the left navigation. Then scroll to the bottom of the page and enter in the name of the variant in Variant field and press the + button. Configure the variant in the resulting right hand panel. Adding a new variant Variant Inheritance \u00b6 When creating a new variant, you very rarely need to start from scratch. Let's say you already built your primary button, but now you just need an icon version. Instead of rebuilding all of your styles, you can set your new primaryIconic button to inherit all of the default values from the primary button. Once you set that up, you can add in any overrides you need, maybe the width or border-radius for example. Adding a new variant","title":"UI Theme"},{"location":"setup/branding/builder/#ui-builder-overview","text":"The UI Builder is an application that empowers users with the ability to style UI elements and make visual changes to UI elements in-real time. UI Builder is aimed at designers and other non-technical users to be able to make UI style changes quickly. By making UI style changes through UI Builder, users do not need to know how to code, manipulate HTML/CSS, or redeploy a project. Designers can make styling changes independently of engineers building out the application. This reduces the need to ask engineers to make styling changes and shortens the communication loop. Active Themes Active themes should only be used on dev environments. In your staging and production environments, engineers will export the theme during the deployment so that it is \"static\". This ensures that designers do not accidentally turn an entire production interface pink, for example.","title":"UI Builder Overview"},{"location":"setup/branding/builder/#navigating-the-ui-builder","text":"Every project has it's own UI builder project associated with it. If a given project has multiple UIs, the same UI builder project or multiple UI builder projects can be used per UI. UI Builder projects are organized by the type of UI element you are editing. You can find the categories down the left side of the project. UI Builder Project When a user clicks into a specific UI element, they can visually see an example of the UI element and can manually update nearly every aspect of it (e.g. color, padding, borders, hover states etc.). Any changes they make to the element are live changes to the development UI. UI Builder Element Editor","title":"Navigating the UI Builder"},{"location":"setup/branding/builder/#variants","text":"Each UI type has variations of that element called variants. A variant is a way to reuse the style of a given element in multiple places. For example, if a designer wants to use the same style button on two different places in the UI, they would use the same variant and any changes made to that variant on UI Builder will update both of those buttons. This means that all the designer has to do is specify to the engineer that a given button should inherit a given variant. It also means the engineer can code/place the button and the designer can then use the UI builder to fine tune how it looks. For some components, the variant can be specified in configuration panel of the UI component itself rather than needing to communicate it to the engineer.","title":"Variants"},{"location":"setup/branding/builder/#creating-a-new-variant","text":"Create a variant by clicking the type of UI element in the left navigation. Then scroll to the bottom of the page and enter in the name of the variant in Variant field and press the + button. Configure the variant in the resulting right hand panel. Adding a new variant","title":"Creating a New Variant"},{"location":"setup/branding/builder/#variant-inheritance","text":"When creating a new variant, you very rarely need to start from scratch. Let's say you already built your primary button, but now you just need an icon version. Instead of rebuilding all of your styles, you can set your new primaryIconic button to inherit all of the default values from the primary button. Once you set that up, you can add in any overrides you need, maybe the width or border-radius for example. Adding a new variant","title":"Variant Inheritance"},{"location":"setup/branding/empty-states/","text":"Empty States & Illustrations \u00b6 No one likes a blank screen. That's why we've given you the ability to add helpful text hints, illustrations, and help links to the different empty states users might come across in the UI. Edit blueprint metadata in the info tab No Data to Load \u00b6 When your users are just starting out with your UI and they haven't added any data yet, they may need some help to guide them in the right direction. That's why we've given you the ability to configure the empty states of certain components, like the table & card list. You can make these changes for a given blueprint in the blueprint's metadata. Configuration options Metadata Example { \"strings\" : { \"noDataTitle\" : \"Add Your Assets\" , \"noDataBody\" : \"Ready to import your asset inventory? Upload your assets in bulk or individually.\" , \"noDataDocLink\" : \"https://www.google.com/\" }, \"icons\" : { \"noData\" : \"https://molten-ui-assets.storage.googleapis.com/no-data.svg\" } } No Search Results \u00b6 Sometimes your user searches for something that just doesn't exist. To help them along the way, and account for any special search and filter behaviors you might have in your application, you can customize your empty search results table & list message per blueprint. Configuration options Metadata Example { \"strings\" : { \"noSearchResultsTitle\" : \"We Couldn't Find Any Matches For That\" , \"noSearchResultsBody\" : \"Please try another search query.\" , }, \"icons\" : { \"noSearchResults\" : \"https://molten-ui-assets.storage.googleapis.com/no-search-results.svg\" } } SVG files will have the best resolution","title":"Empty States"},{"location":"setup/branding/empty-states/#empty-states-illustrations","text":"No one likes a blank screen. That's why we've given you the ability to add helpful text hints, illustrations, and help links to the different empty states users might come across in the UI. Edit blueprint metadata in the info tab","title":"Empty States &amp; Illustrations"},{"location":"setup/branding/empty-states/#no-data-to-load","text":"When your users are just starting out with your UI and they haven't added any data yet, they may need some help to guide them in the right direction. That's why we've given you the ability to configure the empty states of certain components, like the table & card list. You can make these changes for a given blueprint in the blueprint's metadata. Configuration options Metadata Example { \"strings\" : { \"noDataTitle\" : \"Add Your Assets\" , \"noDataBody\" : \"Ready to import your asset inventory? Upload your assets in bulk or individually.\" , \"noDataDocLink\" : \"https://www.google.com/\" }, \"icons\" : { \"noData\" : \"https://molten-ui-assets.storage.googleapis.com/no-data.svg\" } }","title":"No Data to Load"},{"location":"setup/branding/empty-states/#no-search-results","text":"Sometimes your user searches for something that just doesn't exist. To help them along the way, and account for any special search and filter behaviors you might have in your application, you can customize your empty search results table & list message per blueprint. Configuration options Metadata Example { \"strings\" : { \"noSearchResultsTitle\" : \"We Couldn't Find Any Matches For That\" , \"noSearchResultsBody\" : \"Please try another search query.\" , }, \"icons\" : { \"noSearchResults\" : \"https://molten-ui-assets.storage.googleapis.com/no-search-results.svg\" } } SVG files will have the best resolution","title":"No Search Results"},{"location":"setup/branding/icons/","text":"Icon Configuration \u00b6 There are many situations where you will want to customize your icons, whether they are for your navigation, map, headers, or lists. This is easily accomplished by adding metadata via Architect. Before following along, please ensure you have access to our Architect UI. Edit blueprint metadata in the info tab Storing Icons Prior to any of this configuration, the icons must be uploaded to the cloud and hosted publically. We suggest using GCP for this step. You also must know the URL of each icon state. Map Icons \u00b6 The metadata for map icons are found under the mapbox property, which is further subdivided by the icon state. Supported icon types for the map include your default icons (normal, rollover, selected, rollover-selected) and your historical point icons (history, history-rollover, history-selected). Format: PNG Current Location Icon States \u00b6 Possible icon states for the current location of a device on the map History Location Icon States \u00b6 Possible icon states for a historical point of a device on the map Map Examples \u00b6 Example of icons used in map context Metadata Example \u00b6 Icon State Fields Field Definition src The URL of the icon height Height of the icon (px) width Width of the icon (px) { \"icons\" : { \"mapbox\" : { \"history\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history.png\" , \"width\" : 48 }, \"history-rollover\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history-rollover.png\" , \"width\" : 48 }, \"history-selected\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history-selected.png\" , \"width\" : 48 }, \"normal\" : { \"height\" : 53 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-normal.png\" , \"width\" : 53 }, \"rollover\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-rollover.png\" , \"width\" : 80 }, \"rollover-selected\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-rollover-selected.png\" , \"width\" : 80 }, \"selected\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-selected.png\" , \"width\" : 80 } } Property Image Naming Convention normal blueprint-normal.png rollover blueprint-rollover.png selected blueprint-selected.png rollover-selected blueprint-rollover-selected.png history Global Icon: history.png, Blueprint-Specific Icon: blueprint-history.png history-rollover Global Icon: history-rollover.png, Blueprint-Specific Icon: blueprint-history-rollover.png history-selected Global Icon: history-selected.png, Blueprint-Specific Icon: blueprint-history-selected.png Navigation Icons \u00b6 The navIcon property is used in the top navigation bar and the sidebar, as well as the mobile navigation menu. You can set the default icon in the blueprint metadata. Format: SVG or PNG Icon usage in navigation Metadata Example \u00b6 { \"icons\" : { \"navIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-nav.svg\" } } Property Image Naming Convention navIcon blueprint-nav.svg Title Icons \u00b6 The screenIcon property is used in the header section of a given page. You can set the default icon in the blueprint metadata. Format: SVG or PNG Icon usage in screen titles Metadata Example \u00b6 { \"icons\" : { \"screenIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-title.svg\" } } Property Image Naming Convention screenIcon blueprint-title.svg Type Icons \u00b6 The typeIcon property is used in list cards, selection cards, and more. You can set the default icon in the blueprint metadata. Format: SVG or PNG Metadata Example \u00b6 { \"icons\" : { \"typeIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-normal.png\" } } For screen icons, some people prefer to use the same icon they used for the normal map property. If so, you will use the same file with the naming convention blueprint-normal.png. If you want to use a seperate file, follow the naming convention below. Property Image Naming Convention typeIcon blueprint-type.svg","title":"Icons"},{"location":"setup/branding/icons/#icon-configuration","text":"There are many situations where you will want to customize your icons, whether they are for your navigation, map, headers, or lists. This is easily accomplished by adding metadata via Architect. Before following along, please ensure you have access to our Architect UI. Edit blueprint metadata in the info tab Storing Icons Prior to any of this configuration, the icons must be uploaded to the cloud and hosted publically. We suggest using GCP for this step. You also must know the URL of each icon state.","title":"Icon Configuration"},{"location":"setup/branding/icons/#map-icons","text":"The metadata for map icons are found under the mapbox property, which is further subdivided by the icon state. Supported icon types for the map include your default icons (normal, rollover, selected, rollover-selected) and your historical point icons (history, history-rollover, history-selected). Format: PNG","title":"Map Icons"},{"location":"setup/branding/icons/#current-location-icon-states","text":"Possible icon states for the current location of a device on the map","title":"Current Location Icon States"},{"location":"setup/branding/icons/#history-location-icon-states","text":"Possible icon states for a historical point of a device on the map","title":"History Location Icon States"},{"location":"setup/branding/icons/#map-examples","text":"Example of icons used in map context","title":"Map Examples"},{"location":"setup/branding/icons/#metadata-example","text":"Icon State Fields Field Definition src The URL of the icon height Height of the icon (px) width Width of the icon (px) { \"icons\" : { \"mapbox\" : { \"history\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history.png\" , \"width\" : 48 }, \"history-rollover\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history-rollover.png\" , \"width\" : 48 }, \"history-selected\" : { \"height\" : 48 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/history-selected.png\" , \"width\" : 48 }, \"normal\" : { \"height\" : 53 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-normal.png\" , \"width\" : 53 }, \"rollover\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-rollover.png\" , \"width\" : 80 }, \"rollover-selected\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-rollover-selected.png\" , \"width\" : 80 }, \"selected\" : { \"height\" : 80 , \"src\" : \"https://molten-ui-assets.storage.googleapis.com/asset-selected.png\" , \"width\" : 80 } } Property Image Naming Convention normal blueprint-normal.png rollover blueprint-rollover.png selected blueprint-selected.png rollover-selected blueprint-rollover-selected.png history Global Icon: history.png, Blueprint-Specific Icon: blueprint-history.png history-rollover Global Icon: history-rollover.png, Blueprint-Specific Icon: blueprint-history-rollover.png history-selected Global Icon: history-selected.png, Blueprint-Specific Icon: blueprint-history-selected.png","title":"Metadata Example"},{"location":"setup/branding/icons/#navigation-icons","text":"The navIcon property is used in the top navigation bar and the sidebar, as well as the mobile navigation menu. You can set the default icon in the blueprint metadata. Format: SVG or PNG Icon usage in navigation","title":"Navigation Icons"},{"location":"setup/branding/icons/#metadata-example_1","text":"{ \"icons\" : { \"navIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-nav.svg\" } } Property Image Naming Convention navIcon blueprint-nav.svg","title":"Metadata Example"},{"location":"setup/branding/icons/#title-icons","text":"The screenIcon property is used in the header section of a given page. You can set the default icon in the blueprint metadata. Format: SVG or PNG Icon usage in screen titles","title":"Title Icons"},{"location":"setup/branding/icons/#metadata-example_2","text":"{ \"icons\" : { \"screenIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-title.svg\" } } Property Image Naming Convention screenIcon blueprint-title.svg","title":"Metadata Example"},{"location":"setup/branding/icons/#type-icons","text":"The typeIcon property is used in list cards, selection cards, and more. You can set the default icon in the blueprint metadata. Format: SVG or PNG","title":"Type Icons"},{"location":"setup/branding/icons/#metadata-example_3","text":"{ \"icons\" : { \"typeIcon\" : \"https://molten-ui-assets.storage.googleapis.com/asset-normal.png\" } } For screen icons, some people prefer to use the same icon they used for the normal map property. If so, you will use the same file with the naming convention blueprint-normal.png. If you want to use a seperate file, follow the naming convention below. Property Image Naming Convention typeIcon blueprint-type.svg","title":"Metadata Example"},{"location":"setup/branding/inspector/","text":"UI Inspector Overview \u00b6 Enabling the Inspector The inspector should only be enabled in your development environment. Engineers can enable the inspector per UI. Once the inspector is enabled, you can toggle it on and off using the keyboard shortcut Ctrl + i The UI inspector allows designers to hover over any UI element in the interface and quickly see the element type and variant name. Because every element is nested in another, the inspector will show the child, then each consecutive parent in the panel. If the element in question is a pane, the inspector will include the layout as well. Inspector","title":"UI Inspector"},{"location":"setup/branding/inspector/#ui-inspector-overview","text":"Enabling the Inspector The inspector should only be enabled in your development environment. Engineers can enable the inspector per UI. Once the inspector is enabled, you can toggle it on and off using the keyboard shortcut Ctrl + i The UI inspector allows designers to hover over any UI element in the interface and quickly see the element type and variant name. Because every element is nested in another, the inspector will show the child, then each consecutive parent in the panel. If the element in question is a pane, the inspector will include the layout as well. Inspector","title":"UI Inspector Overview"},{"location":"setup/branding/logos/","text":"Updating Logos & Images \u00b6 The logos used in the interfaces are stored in the UI builder in various places. Below, we will show you where each logo is located so that you can update them anytime. Logo Storage The UI Builder does not store any files. Before you begin, please host your logos publically on the web. We suggest using GCP for this step. Top Navigation Logo \u00b6 Top Navigation Logo Element Type: Button Variant Name: navLogo Mobile Override: mobileNavLogo SVG Format for Best Resolution Once you have located the variant, select the variant and navigate to the right hand panel. There, you will select the property tab and paste your URL. Paste URL into icon property field Login Page Options \u00b6 Login Page There are two branding assets that can be configured on this page. Company logo Background image (behind the white box) Login Logo \u00b6 The login logo is a different element & variant in the UI builder than the navLogo. The variant information is below. Element Type: Text Variant Name: loginLogo Edit the logo by navigating to the property tab and pasting the URL (same process as above) Login Background \u00b6 The login background is a pane and the image will be added as the URL of the background property. Element Type: Pane Variant Name: loginBackground Paste URL into background image field","title":"Logos"},{"location":"setup/branding/logos/#updating-logos-images","text":"The logos used in the interfaces are stored in the UI builder in various places. Below, we will show you where each logo is located so that you can update them anytime. Logo Storage The UI Builder does not store any files. Before you begin, please host your logos publically on the web. We suggest using GCP for this step.","title":"Updating Logos &amp; Images"},{"location":"setup/branding/logos/#top-navigation-logo","text":"Top Navigation Logo Element Type: Button Variant Name: navLogo Mobile Override: mobileNavLogo SVG Format for Best Resolution Once you have located the variant, select the variant and navigate to the right hand panel. There, you will select the property tab and paste your URL. Paste URL into icon property field","title":"Top Navigation Logo"},{"location":"setup/branding/logos/#login-page-options","text":"Login Page There are two branding assets that can be configured on this page. Company logo Background image (behind the white box)","title":"Login Page Options"},{"location":"setup/branding/logos/#login-logo","text":"The login logo is a different element & variant in the UI builder than the navLogo. The variant information is below. Element Type: Text Variant Name: loginLogo Edit the logo by navigating to the property tab and pasting the URL (same process as above)","title":"Login Logo"},{"location":"setup/branding/logos/#login-background","text":"The login background is a pane and the image will be added as the URL of the background property. Element Type: Pane Variant Name: loginBackground Paste URL into background image field","title":"Login Background"},{"location":"setup/branding/notifications/","text":"Email & SMS Templates \u00b6 We provide three email templates out of the box in Architect. Any email template can be customized using our html editor. Below, we'll walk through how you can easily create and customize your emails. Adding a Template Our available templates are all easy to add under the New Template button in the top right corner Templates in Architect Available Templates \u00b6 Name Alias Purpose Invitation activateAccount When a user is invited to the system, they will receive this email invitation Reset Password resetPassword When a user selects forgot password via the login screen, they will receive this email Reset Password Successful resetPasswordSuccess After a user resets their password, they will receive a confirmation email Profile Changed profileChanged If a user changes any of their profile information, they will receive a confirmation email Login Code loginCode If a user requests a one-time access code via email, they will receive this email with the requested code Two-Step Verification twoFactorCode If a user enables two-step verification with their email, when they try to sign in they will receive this email as the second step in the process Login Code Error loginCodeError Users can not request one-time access codes with the same email that has two-step verification enabled. If they try to request a code, they will receive this email Editing Your Template \u00b6 When you select a template, you will see three tabs. Make sure you save any changes you make in the top right corner. Do not change the alias of a template Tabs Overview Info: Contains the name of the template and the alias . Editing the alias will break the template. Email: Most of the offered templates are email-only. Under the email tab, you will see a handlebar editor where you can edit the email and an email subject text field. Text: If the template has a supported SMS component, you will see the text message under the text tab. Email template editor Supported SMS Templates \u00b6 The following templates also support SMS versions. Name Alias Purpose Login Code loginCode If a user requests a one-time access code via text, they will receive this text with the requested code Two-Step Verification twoFactorCode If a user enables two-step verification with their phone number, when they try to sign in they will receive this text message as the second step in the process Login Code Error loginCodeError Users can not request one-time access codes with the same phone number that has two-step verification enabled. If they try to request a code, they will receive this text Configuring Your Template's Buttons \u00b6 Some email templates include a button that takes you to a given UI. Once you have your UI stood up on the desired URL, you can edit the URL information in a given button to ensure it takes you to the right place. < span style = \"background:#194edc; color:white; padding:10px 20px; border-radius:5px; font-size: 13px;\" > < a style = \"color:white;text-decoration:none;\" href = \"https://yourURLhere/activateAccount?username={{username}}&email={{email}}&token={{activationToken}}{{#if projectId}}&projectId={{projectId}}{{/if}}\" > Join Now </ a > </ span >","title":"Email & SMS Templates"},{"location":"setup/branding/notifications/#email-sms-templates","text":"We provide three email templates out of the box in Architect. Any email template can be customized using our html editor. Below, we'll walk through how you can easily create and customize your emails. Adding a Template Our available templates are all easy to add under the New Template button in the top right corner Templates in Architect","title":"Email &amp; SMS Templates"},{"location":"setup/branding/notifications/#available-templates","text":"Name Alias Purpose Invitation activateAccount When a user is invited to the system, they will receive this email invitation Reset Password resetPassword When a user selects forgot password via the login screen, they will receive this email Reset Password Successful resetPasswordSuccess After a user resets their password, they will receive a confirmation email Profile Changed profileChanged If a user changes any of their profile information, they will receive a confirmation email Login Code loginCode If a user requests a one-time access code via email, they will receive this email with the requested code Two-Step Verification twoFactorCode If a user enables two-step verification with their email, when they try to sign in they will receive this email as the second step in the process Login Code Error loginCodeError Users can not request one-time access codes with the same email that has two-step verification enabled. If they try to request a code, they will receive this email","title":"Available Templates"},{"location":"setup/branding/notifications/#editing-your-template","text":"When you select a template, you will see three tabs. Make sure you save any changes you make in the top right corner. Do not change the alias of a template Tabs Overview Info: Contains the name of the template and the alias . Editing the alias will break the template. Email: Most of the offered templates are email-only. Under the email tab, you will see a handlebar editor where you can edit the email and an email subject text field. Text: If the template has a supported SMS component, you will see the text message under the text tab. Email template editor","title":"Editing Your Template"},{"location":"setup/branding/notifications/#supported-sms-templates","text":"The following templates also support SMS versions. Name Alias Purpose Login Code loginCode If a user requests a one-time access code via text, they will receive this text with the requested code Two-Step Verification twoFactorCode If a user enables two-step verification with their phone number, when they try to sign in they will receive this text message as the second step in the process Login Code Error loginCodeError Users can not request one-time access codes with the same phone number that has two-step verification enabled. If they try to request a code, they will receive this text","title":"Supported SMS Templates"},{"location":"setup/branding/notifications/#configuring-your-templates-buttons","text":"Some email templates include a button that takes you to a given UI. Once you have your UI stood up on the desired URL, you can edit the URL information in a given button to ensure it takes you to the right place. < span style = \"background:#194edc; color:white; padding:10px 20px; border-radius:5px; font-size: 13px;\" > < a style = \"color:white;text-decoration:none;\" href = \"https://yourURLhere/activateAccount?username={{username}}&email={{email}}&token={{activationToken}}{{#if projectId}}&projectId={{projectId}}{{/if}}\" > Join Now </ a > </ span >","title":"Configuring Your Template's Buttons"},{"location":"setup/models/","text":"Models \u00b6 Molten uses the concept of a Model in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON. Characteristics \u00b6 A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them. Plain JSON Object \u00b6 Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism. Immutable \u00b6 Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences. Typed \u00b6 Models should have a type field that defines its unique identity. Normally this is a namespaced string such as myProject.MyModel Working with Models \u00b6 There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the @leverege/model-util library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: import MyModel from './MyModel' // If model was defined as model = { type : 'myMode' , value : 5 , subValues : { sv : 1 } } // WRONG - Dont do this model . value = 42 // CORRECT - Do this const nModel = MyModel . setValue ( model , 42 ) model === nModel // => false model . subValues === nModel . subValues // => true The @leverege/model-util will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking Plugins.add( 'Model', MyModel ) . Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type. If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network.","title":"Models"},{"location":"setup/models/#models","text":"Molten uses the concept of a Model in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON.","title":"Models"},{"location":"setup/models/#characteristics","text":"A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them.","title":"Characteristics"},{"location":"setup/models/#plain-json-object","text":"Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism.","title":"Plain JSON Object"},{"location":"setup/models/#immutable","text":"Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences.","title":"Immutable"},{"location":"setup/models/#typed","text":"Models should have a type field that defines its unique identity. Normally this is a namespaced string such as myProject.MyModel","title":"Typed"},{"location":"setup/models/#working-with-models","text":"There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the @leverege/model-util library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: import MyModel from './MyModel' // If model was defined as model = { type : 'myMode' , value : 5 , subValues : { sv : 1 } } // WRONG - Dont do this model . value = 42 // CORRECT - Do this const nModel = MyModel . setValue ( model , 42 ) model === nModel // => false model . subValues === nModel . subValues // => true The @leverege/model-util will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking Plugins.add( 'Model', MyModel ) . Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type. If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network.","title":"Working with Models"},{"location":"setup/models/editors/","text":"Model Editors \u00b6 ModelEditorFactory useValueChange Hook - Model and eventData Recursive ModelEditors in ModelEditors","title":"Model Editors"},{"location":"setup/models/editors/#model-editors","text":"ModelEditorFactory useValueChange Hook - Model and eventData Recursive ModelEditors in ModelEditors","title":"Model Editors"},{"location":"setup/models/model-util/","text":"Model Util \u00b6 Example createAllValue createAllArray discussion about normalization of this into { get, indexOf, removeAt, etc } createAllMap discussion about normalization of this into { get, indexOf, removeAt, etc }","title":"Model Util"},{"location":"setup/models/model-util/#model-util","text":"Example createAllValue createAllArray discussion about normalization of this into { get, indexOf, removeAt, etc } createAllMap discussion about normalization of this into { get, indexOf, removeAt, etc }","title":"Model Util"},{"location":"setup/nav/","text":"Plugins \u00b6 Molten makes heavy use of the @leverege/plugins library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few. Use \u00b6 The use of this library can be very simple and the requirements are very few: Including the library in your own code Defining an interface for your custom plugin mechanism (sometimes called Plugin Points) Picking a unique plugin name for your mechanism (usually namespaced, like . ) import { Plugins } from '@leverege/plugin' // 1 const plgs = Plugins . get ( 'myProject.Initializer' ) // 2 plgs . forEach ( ( initializer ) => { initializer . init () // 3 } ) In this example, we have defined our own custom plugin point that will invoke an init method at the appropriate time. It has imported the library (1), asked for all plugins registered as a myProject.Initializer plugin (2), and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. To participate in that example plugin point, simply add a plugin to the Plugin mechanism: import { Plugins } from '@leverege/plugin' // 1 MyInitializer = { init : () => { /* do something */ } } // Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer ) Plugins . add ( 'myProject.Initializer' , MyInitializer ) This Plugins.add() or molten.addPlugin() registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. Some plugin points are a little more complicated. These plugin points will often use match objects , type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values (like Molten's initializer plugins ) to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views . These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point. Observable \u00b6 The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. // Add a listener to all types const unsubscribeGlobal = Plugins . on ( listener ) // Add a listener to a specific type const unsubscribeType = Plugins . on ( 'myProject.Initializer' , listener ) // To remove a listener from all types Plugins . off ( listener ) // or use the returned function unsubscribeGlobal () // To remove a listener from a specific type Plugins . off ( 'myProject.Initializer' , listener ) // or use the returned function unsubscribeType () The listener method will be invoked with an object when an add or remove occurs: { type , // either 'pluginAdded' or 'pluginRemoved', pluginType , // The plugin type that changed plugin , // The plugin that was added or removed plugins // The Plugins object } An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. const version = Plugins . getVersion ( 'myProject.Initializer' ) Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set. const version = Plugins . getVersion ( 'myProject.PluginPoint' ) // React Example const result = useMemo ( ( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, [ version ] ) // @leverege/value-cache example const result = valueCache . calc (( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, version )","title":"Plugins"},{"location":"setup/nav/#plugins","text":"Molten makes heavy use of the @leverege/plugins library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few.","title":"Plugins"},{"location":"setup/nav/#use","text":"The use of this library can be very simple and the requirements are very few: Including the library in your own code Defining an interface for your custom plugin mechanism (sometimes called Plugin Points) Picking a unique plugin name for your mechanism (usually namespaced, like . ) import { Plugins } from '@leverege/plugin' // 1 const plgs = Plugins . get ( 'myProject.Initializer' ) // 2 plgs . forEach ( ( initializer ) => { initializer . init () // 3 } ) In this example, we have defined our own custom plugin point that will invoke an init method at the appropriate time. It has imported the library (1), asked for all plugins registered as a myProject.Initializer plugin (2), and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. To participate in that example plugin point, simply add a plugin to the Plugin mechanism: import { Plugins } from '@leverege/plugin' // 1 MyInitializer = { init : () => { /* do something */ } } // Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer ) Plugins . add ( 'myProject.Initializer' , MyInitializer ) This Plugins.add() or molten.addPlugin() registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. Some plugin points are a little more complicated. These plugin points will often use match objects , type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values (like Molten's initializer plugins ) to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views . These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point.","title":"Use"},{"location":"setup/nav/#observable","text":"The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. // Add a listener to all types const unsubscribeGlobal = Plugins . on ( listener ) // Add a listener to a specific type const unsubscribeType = Plugins . on ( 'myProject.Initializer' , listener ) // To remove a listener from all types Plugins . off ( listener ) // or use the returned function unsubscribeGlobal () // To remove a listener from a specific type Plugins . off ( 'myProject.Initializer' , listener ) // or use the returned function unsubscribeType () The listener method will be invoked with an object when an add or remove occurs: { type , // either 'pluginAdded' or 'pluginRemoved', pluginType , // The plugin type that changed plugin , // The plugin that was added or removed plugins // The Plugins object } An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. const version = Plugins . getVersion ( 'myProject.Initializer' ) Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set. const version = Plugins . getVersion ( 'myProject.PluginPoint' ) // React Example const result = useMemo ( ( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, [ version ] ) // @leverege/value-cache example const result = valueCache . calc (( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, version )","title":"Observable"},{"location":"setup/nav/page/","text":"Screen Display Options \u00b6 Nesting Screen Display \u00b6 So far, we have used the automatic screen display option, which we call the nesting display. For the nesting display, when you select an item, you are drilled into an entirely new page about that item, featuring a sidebar of that item's children (example below). Nesting Screen Display Embedded Screen Display \u00b6 In many cases, you don't want the entire page to change when you click on an item. Instead, you want the details of a specific item to replace the item list. For example, if you are looking at a list of assets in your location and you select one to learn more, you might not want the side navigation to change to display that asset and it's children. Embedded Screen Display In the image above, you can see the asset details screen replaced the list screen without changing the side navigation. On top of that, in the event that the asset is the parent in a relationship, you will see those child blueprint pages in the top section of the asset detail view. The tag to embed a screen is itemScreen:embed . This is a tag added to the relationship attribute of the blueprint you want to embed. No Screen Display \u00b6 Sometimes, you don't want your user to drill into an item at all. The tag to hide the drill down page all together is itemScreen:none .","title":"Page Display Options"},{"location":"setup/nav/page/#screen-display-options","text":"","title":"Screen Display Options"},{"location":"setup/nav/page/#nesting-screen-display","text":"So far, we have used the automatic screen display option, which we call the nesting display. For the nesting display, when you select an item, you are drilled into an entirely new page about that item, featuring a sidebar of that item's children (example below). Nesting Screen Display","title":"Nesting Screen Display"},{"location":"setup/nav/page/#embedded-screen-display","text":"In many cases, you don't want the entire page to change when you click on an item. Instead, you want the details of a specific item to replace the item list. For example, if you are looking at a list of assets in your location and you select one to learn more, you might not want the side navigation to change to display that asset and it's children. Embedded Screen Display In the image above, you can see the asset details screen replaced the list screen without changing the side navigation. On top of that, in the event that the asset is the parent in a relationship, you will see those child blueprint pages in the top section of the asset detail view. The tag to embed a screen is itemScreen:embed . This is a tag added to the relationship attribute of the blueprint you want to embed.","title":"Embedded Screen Display"},{"location":"setup/nav/page/#no-screen-display","text":"Sometimes, you don't want your user to drill into an item at all. The tag to hide the drill down page all together is itemScreen:none .","title":"No Screen Display"},{"location":"setup/nav/path-overrides/","text":"Styling Overrides \u00b6 To override any blueprint metadata at a specific relationship path, add the property to the metadata of the relationship attribute. For example, to override the location navicon at the company level, you\u2019ll go to the company blueprint\u2019s location attribute and add the metadata. You can override anything from icons & strings to illustrations and documentation links. Anything you have been able to configure thus far can be changed.","title":"Styling Overrides"},{"location":"setup/nav/path-overrides/#styling-overrides","text":"To override any blueprint metadata at a specific relationship path, add the property to the metadata of the relationship attribute. For example, to override the location navicon at the company level, you\u2019ll go to the company blueprint\u2019s location attribute and add the metadata. You can override anything from icons & strings to illustrations and documentation links. Anything you have been able to configure thus far can be changed.","title":"Styling Overrides"},{"location":"setup/nav/route/","text":"Roots \u00b6 In your UI, you have the ability to decide which blueprint or blueprints will be your root(s). By making a blueprint a root, you are selecting that blueprint to be the root of your hierarchy for that section of the UI. The root page will load a system-wide list of every item of that blueprint type. Let's take the hierarchy below as our example. Hierarchy diagram Let's break down the relationships in the example above. The company blueprint has 3 child relationships, all of which are one-to-many. The child blueprints are: Location Blueprint Asset Blueprint Tracker Blueprint The location blueprint also has child relationships, all of which are one-to-many. These child blueprints are: Asset Blueprint Tracker Blueprint Zone Blueprint Beacon Blueprint Floor Blueprint For a refresher on relationship types and usages, { please refer to this link. } Selecting Roots \u00b6 You can have one root or multiple roots in your UI. In this case, it makes sense for the company blueprint to be a root, which will make the company blueprint a top level navigation option. Company root example On top of adding companies to the top level navigation, the root also will only load that blueprint and it's children. For example, if you selected the location blueprint as a root along with the company blueprint, you would see both in the top nav (example below). Multi-root example Under the location's tab, you will have entirely new set of pages, representing the child blueprints, in your UI. This pages will be completely separate from the pages representing the same blueprint under the company root. To help visual this, take a look at the diagram below. Multi-root hierarchy Root Groups \u00b6 In some cases, it's helpful to see your assets or trackers across all companies or locations at the root level. In these types of cases, we find it helpful to group those pages together. The grouping mechanism puts a group of root pages into a dropdown in the top navigation, saving you critical screen space. Group dropdown example These pages will load individually, so you will have one page for a system-wide list of assets and one for a system-wide list of trackers. Configuring Roots \u00b6 To make a blueprint a root, all you have to do is add the tag is:root to the blueprint tag section. Group dropdown example Below are the different types of configuration options for roots via tags. Property Purpose is:root Adds the blueprint to the top-level navigation as a root rootNavGroup:<Name> If a blueprint is set as a root, it can be added to a group in the top navigation. Name represents which group the blueprint is added to and is used in the label of the dropdown rootNavGroupIcons:<URL> To set the icon for a group, use this tag on any blueprint in that group. This icon must be hosted publicly online Hiding Roots from Specific Roles \u00b6 Not every role should have the same access, and the same goes for roots. You can easily hide a root from a given role by using the tag excludeFrom:<Role> Property Purpose excludeFrom:<Role> Hides this root from a given role excludeFrom:* Hides this root from all roles. Useful when more than one UI is used for a given project and a root is only needed for one of the two UIs. Note that this requires mutations to implement.","title":"Roots"},{"location":"setup/nav/route/#roots","text":"In your UI, you have the ability to decide which blueprint or blueprints will be your root(s). By making a blueprint a root, you are selecting that blueprint to be the root of your hierarchy for that section of the UI. The root page will load a system-wide list of every item of that blueprint type. Let's take the hierarchy below as our example. Hierarchy diagram Let's break down the relationships in the example above. The company blueprint has 3 child relationships, all of which are one-to-many. The child blueprints are: Location Blueprint Asset Blueprint Tracker Blueprint The location blueprint also has child relationships, all of which are one-to-many. These child blueprints are: Asset Blueprint Tracker Blueprint Zone Blueprint Beacon Blueprint Floor Blueprint For a refresher on relationship types and usages, { please refer to this link. }","title":"Roots"},{"location":"setup/nav/route/#selecting-roots","text":"You can have one root or multiple roots in your UI. In this case, it makes sense for the company blueprint to be a root, which will make the company blueprint a top level navigation option. Company root example On top of adding companies to the top level navigation, the root also will only load that blueprint and it's children. For example, if you selected the location blueprint as a root along with the company blueprint, you would see both in the top nav (example below). Multi-root example Under the location's tab, you will have entirely new set of pages, representing the child blueprints, in your UI. This pages will be completely separate from the pages representing the same blueprint under the company root. To help visual this, take a look at the diagram below. Multi-root hierarchy","title":"Selecting Roots"},{"location":"setup/nav/route/#root-groups","text":"In some cases, it's helpful to see your assets or trackers across all companies or locations at the root level. In these types of cases, we find it helpful to group those pages together. The grouping mechanism puts a group of root pages into a dropdown in the top navigation, saving you critical screen space. Group dropdown example These pages will load individually, so you will have one page for a system-wide list of assets and one for a system-wide list of trackers.","title":"Root Groups"},{"location":"setup/nav/route/#configuring-roots","text":"To make a blueprint a root, all you have to do is add the tag is:root to the blueprint tag section. Group dropdown example Below are the different types of configuration options for roots via tags. Property Purpose is:root Adds the blueprint to the top-level navigation as a root rootNavGroup:<Name> If a blueprint is set as a root, it can be added to a group in the top navigation. Name represents which group the blueprint is added to and is used in the label of the dropdown rootNavGroupIcons:<URL> To set the icon for a group, use this tag on any blueprint in that group. This icon must be hosted publicly online","title":"Configuring Roots"},{"location":"setup/nav/route/#hiding-roots-from-specific-roles","text":"Not every role should have the same access, and the same goes for roots. You can easily hide a root from a given role by using the tag excludeFrom:<Role> Property Purpose excludeFrom:<Role> Hides this root from a given role excludeFrom:* Hides this root from all roles. Useful when more than one UI is used for a given project and a root is only needed for one of the two UIs. Note that this requires mutations to implement.","title":"Hiding Roots from Specific Roles"},{"location":"setup/nav/sort/","text":"Sort & Order Pages \u00b6 Once you have selected and set up your root, you will find that by clicking on a root item, you are taken to a new page in the UI with a sidebar navigation. For example, let\u2019s look at our example with locations. Location example The sidebar navigation includes: An overview page of the item, named Overview All blueprints that have the location blueprint as a parent, regardless of if the relationship is one-to-one or one-to-many If user management is enabled, a users page. For more information on enabling user management, review {==our documentation here. ==} !!! Tip \u201cIcons\u201d Reminder that the icons loading into the side navigation were set in the blueprint metadata. Revisit our icons documentation to review this process. Sections & Ordering \u00b6 Desired Layout We are going to break down how you get from the left sidebar navigation above to the right sidebar. To start, let\u2019s break out and order our sections. The tag to order your blueprints is navSort:<SORT_KEY> , where the sort key is comprised of a letter that determines the section and a number that determines the order. The letter and number are separated by a period. Each blueprint's tag is outlined below. Assets: navSort:a.1 Trackers: navSort:a.2 Beacons: navSort:b.1 Floors: navSort:b.2 Zones: navSort:b.3 Because you are sorting the children relationships of a location, these tags get added to the relationship attribute of each blueprint on the location blueprint (image below). Once the tags are applied, you will see a divider align appear between section a & b. Relationship attribute editor The overview and users pages are ordered with different tags. These tags are added to the location blueprint itself. Tag Purpose navSortOverview:<SORT_KEY> To order the overview page, add this tag to the parent blueprint navSortUserManagement:<SORT_KEY> To order the users page, add this tag to the parent blueprint For our example we're working on, the overview and users tags would follow the example below. Overview: navSortOverview:c.1 Users: navSortUserManagement:c.2 Now that we've added all of our tags, our sidebar should look like the sidebar on the left in the image below. We'll be reviewing how to add section titles next. Sections & Ordering Outcome/figcaption> Section Names \u00b6 To add a section name, you'll want to identify the first page in each section. For our inventory section, the first page is the assets attribute. This is where you will add the tag navSectionName:<NAME> . If you want to add the section name above the user management or overview pages, you will need to add a string to your metadata on the parent blueprint. In this case, we would add the string to the metadata on the location blueprint. String Purpose overviewSectionName If the overview page is the first page in a section, add this string to the parent blueprint metadata with the desired name. userManagementSectionName If the users page is the first page in a section, add this string to the parent blueprint metadata with the desired name. For our example, we added the two tags below. On the assets attribute at the location blueprint: navSectionName:Inventory On the beacons attribute at the location blueprint: navSectionName:Installation To add the location management section name, we added the following metadata to the location blueprint. { \"strings\" : { \"overviewSectionName\" : \"Location Management\" } Hiding Pages from Roles \u00b6 Not every role permissioned to a location should have access to every page. To quickly and easily hide a page from a role, use the excludeFrom:<Role> tag on the relationship attribute if the page is a blueprint. The user management page will only appear if the user has permission to perform user management actions. The overview page will appear for any user permissioned to that blueprint.","title":"Sort & Order Pages"},{"location":"setup/nav/sort/#sort-order-pages","text":"Once you have selected and set up your root, you will find that by clicking on a root item, you are taken to a new page in the UI with a sidebar navigation. For example, let\u2019s look at our example with locations. Location example The sidebar navigation includes: An overview page of the item, named Overview All blueprints that have the location blueprint as a parent, regardless of if the relationship is one-to-one or one-to-many If user management is enabled, a users page. For more information on enabling user management, review {==our documentation here. ==} !!! Tip \u201cIcons\u201d Reminder that the icons loading into the side navigation were set in the blueprint metadata. Revisit our icons documentation to review this process.","title":"Sort &amp; Order Pages"},{"location":"setup/nav/sort/#sections-ordering","text":"Desired Layout We are going to break down how you get from the left sidebar navigation above to the right sidebar. To start, let\u2019s break out and order our sections. The tag to order your blueprints is navSort:<SORT_KEY> , where the sort key is comprised of a letter that determines the section and a number that determines the order. The letter and number are separated by a period. Each blueprint's tag is outlined below. Assets: navSort:a.1 Trackers: navSort:a.2 Beacons: navSort:b.1 Floors: navSort:b.2 Zones: navSort:b.3 Because you are sorting the children relationships of a location, these tags get added to the relationship attribute of each blueprint on the location blueprint (image below). Once the tags are applied, you will see a divider align appear between section a & b. Relationship attribute editor The overview and users pages are ordered with different tags. These tags are added to the location blueprint itself. Tag Purpose navSortOverview:<SORT_KEY> To order the overview page, add this tag to the parent blueprint navSortUserManagement:<SORT_KEY> To order the users page, add this tag to the parent blueprint For our example we're working on, the overview and users tags would follow the example below. Overview: navSortOverview:c.1 Users: navSortUserManagement:c.2 Now that we've added all of our tags, our sidebar should look like the sidebar on the left in the image below. We'll be reviewing how to add section titles next. Sections & Ordering Outcome/figcaption>","title":"Sections &amp; Ordering"},{"location":"setup/nav/sort/#section-names","text":"To add a section name, you'll want to identify the first page in each section. For our inventory section, the first page is the assets attribute. This is where you will add the tag navSectionName:<NAME> . If you want to add the section name above the user management or overview pages, you will need to add a string to your metadata on the parent blueprint. In this case, we would add the string to the metadata on the location blueprint. String Purpose overviewSectionName If the overview page is the first page in a section, add this string to the parent blueprint metadata with the desired name. userManagementSectionName If the users page is the first page in a section, add this string to the parent blueprint metadata with the desired name. For our example, we added the two tags below. On the assets attribute at the location blueprint: navSectionName:Inventory On the beacons attribute at the location blueprint: navSectionName:Installation To add the location management section name, we added the following metadata to the location blueprint. { \"strings\" : { \"overviewSectionName\" : \"Location Management\" }","title":"Section Names"},{"location":"setup/nav/sort/#hiding-pages-from-roles","text":"Not every role permissioned to a location should have access to every page. To quickly and easily hide a page from a role, use the excludeFrom:<Role> tag on the relationship attribute if the page is a blueprint. The user management page will only appear if the user has permission to perform user management actions. The overview page will appear for any user permissioned to that blueprint.","title":"Hiding Pages from Roles"}]}